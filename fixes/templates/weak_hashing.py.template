{
  "vulnerability_name": "Weak Password Hashing",
  "old_code": "import hashlib\nhash = hashlib.md5(password.encode()).hexdigest()",
  "new_code_minimal": "import bcrypt\nhash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())",
  "new_code_comprehensive": "import bcrypt\nhash = bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=12))\n# Store hash in DB. For verification: bcrypt.checkpw(plain_password.encode(), stored_hash)",
  "explanation": "This fix replaces weak or unsalted hashing (MD5, SHA1 without salt) with bcrypt or argon2. Password hashing requires a slow, salted algorithm to resist brute force and rainbow tables.",
  "security_rationale": "MD5 and SHA1 are fast and deterministic. Attackers can precompute hashes for common passwords. bcrypt/argon2 are designed for passwords: they use a salt and are intentionally slow.",
  "why_ai_generated_this": "AI often suggests hashlib.md5 or hashlib.sha1 because they are simple and appear in old tutorials; it does not emphasize dedicated password hashing.",
  "prerequisites": [
    "pip install bcrypt (or argon2-cffi for argon2)"
  ],
  "additional_steps": [
    "Migrate existing weak hashes to bcrypt on next login or with a one-time migration",
    "Do not use hashlib for passwords; use bcrypt or passlib with bcrypt/argon2"
  ],
  "testing_suggestion": "Verify that hashes differ for the same password (due to salt) and that checkpw returns True for the correct password.",
  "references": [
    "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
    "https://cwe.mitre.org/data/definitions/327.html"
  ]
}
