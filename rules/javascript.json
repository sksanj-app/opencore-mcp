{
  "rules": [
    {
      "id": "sql-injection-string-concat",
      "name": "SQL Injection - String Concatenation",
      "description": "SQL query built with string concatenation allows attacker-controlled input to modify query structure. Use parameterized queries instead.",
      "severity": "critical",
      "pattern": "(?:\\.(query|execute|raw)\\s*\\(\\s*)?[\"'`][^\"'`]*(?:SELECT|INSERT|UPDATE|DELETE|FROM)[^\"'`]*(?:[\"'`]\\s*\\+|[\"'`]\\s*\\+\\s*[^\"'`]*[\"'`])|\\.(query|execute|raw)\\s*\\([^)]*[\"'`][^)]*?\\s*\\+\\s*",
      "fix_template": "Use parameterized queries: db.query('SELECT * FROM users WHERE id = ?', [userId])",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-89",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "Database queries are being built by concatenating user input with SQL strings. An attacker could inject malicious SQL to steal data, modify records, or take over the database.",
      "technical_detail": "String concatenation in SQL queries bypasses parameterization. User input is interpreted as SQL code. Replace with parameterized queries (placeholder ? or $1) that treat input as data, not code.",
      "ai_risk_explanation": "AI often generates this because it's syntactically simpler than parameterized queries. Models default to string concatenation for dynamic values.",
      "vulnerable_example": "db.query(\"SELECT * FROM users WHERE id = \" + userId)",
      "multiline": false
    },
    {
      "id": "sql-injection-template-literal",
      "name": "SQL Injection - Template Literals",
      "description": "SQL query built with template literal interpolation. Backtick strings with ${} embed variables directly into query text.",
      "severity": "critical",
      "pattern": "\\.(query|execute|raw)\\s*\\(\\s*`[^`]*\\$\\{[^}]+\\}",
      "fix_template": "Use parameterized queries: db.query('SELECT * FROM users WHERE id = ?', [userId])",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-89",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "Database queries use template literals to insert user data. This allows SQL injection—attackers can break out of the query and run arbitrary database commands.",
      "technical_detail": "Template literals (`SELECT ... ${userId}`) interpolate values as raw text. Use parameterized queries so the driver escapes and binds values safely.",
      "ai_risk_explanation": "AI focuses on template literals for readability and ignores that SQL needs parameterization, not string interpolation.",
      "vulnerable_example": "db.query(`SELECT * FROM users WHERE id = ${userId}`)",
      "multiline": false
    },
    {
      "id": "nosql-injection",
      "name": "NoSQL Injection",
      "description": "MongoDB/NoSQL query object constructed directly from user input. Operators like $gt, $where can be injected.",
      "severity": "critical",
      "pattern": "\\.(find|findOne|findOneAndUpdate|updateOne|deleteOne|aggregate)\\s*\\([^)]*req\\.(body|query|params)\\b",
      "fix_template": "Validate and sanitize input; avoid passing req.body/query/params directly. Use explicit field mapping and whitelist allowed operators.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-943",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User input is passed directly into database queries. Attackers can inject query operators to bypass authentication, extract all records, or modify data.",
      "technical_detail": "NoSQL injection occurs when user-controlled objects are merged into query filters. Attackers send {\"$gt\": \"\"} or {\"$where\": \"...\"} to alter query logic. Validate and map input explicitly.",
      "ai_risk_explanation": "AI tends to map request body/query to queries 1:1 for convenience, without validating structure.",
      "vulnerable_example": "User.find({ username: req.body.username })",
      "multiline": false
    },
    {
      "id": "command-injection-exec",
      "name": "Command Injection - child_process.exec",
      "description": "exec() called with concatenated or interpolated user input. Spawns a shell; user input can run arbitrary commands.",
      "severity": "critical",
      "pattern": "\\bexec\\s*\\([^)]*(?:[\"'`][^\"'`]*[\"'`]\\s*\\+|\\$\\{[^}]+\\})",
      "fix_template": "Use execFile with array args, or spawn without shell. Never pass user input into exec() command string.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-78",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "Shell commands are built from user input. An attacker can inject commands (e.g., ; rm -rf /) to run arbitrary code on the server.",
      "technical_detail": "exec() runs its argument in a shell. Concatenation or template literals allow injection. Use execFile(cmd, [arg1, arg2]) with no shell, or validate/sanitize input if exec is unavoidable.",
      "ai_risk_explanation": "AI generates exec() with string concatenation for simplicity when asked to run shell commands from variables.",
      "vulnerable_example": "exec(\"ls \" + userInput) or exec(`git clone ${url}`)",
      "multiline": false
    },
    {
      "id": "command-injection-spawn-shell",
      "name": "Command Injection - spawn with shell",
      "description": "spawn() used with shell: true and user-controlled command. Same injection risk as exec().",
      "severity": "critical",
      "pattern": "spawn\\s*\\([^,]+,\\s*\\[\\s*\\]\\s*,\\s*\\{[^}]*shell\\s*:\\s*true",
      "fix_template": "Remove shell: true and pass executable + args as separate array elements. Avoid user input in command when shell is used.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-78",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "A shell is spawned with a command that may include user input. Attackers can inject shell metacharacters to run arbitrary commands.",
      "technical_detail": "spawn(cmd, [], { shell: true }) invokes a shell. If cmd is user-controlled, injection is possible. Use spawn without shell and pass executable + args as array.",
      "ai_risk_explanation": "AI suggests shell: true to fix spawn usage without understanding it reintroduces exec-style injection risks.",
      "vulnerable_example": "spawn(command, [], { shell: true })",
      "multiline": false
    },
    {
      "id": "ldap-injection",
      "name": "LDAP Injection",
      "description": "LDAP filter built with string concatenation. User input can alter filter logic or inject LDAP syntax.",
      "severity": "critical",
      "pattern": "(?:filter\\s*:\\s*|ldap\\.(?:search|find)\\s*\\([^)]*)[\"'`][^\"'`]*[\"'`]\\s*\\+",
      "fix_template": "Escape LDAP special characters in user input or use parameterized/bind APIs. Never concatenate user input into LDAP filters.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-90",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "LDAP search filters are built from user input. Attackers can inject filter syntax to bypass authentication or dump directory data.",
      "technical_detail": "LDAP filters use special chars (*, ), (, \\). Concatenating user input allows injection. Escape input or use safe bind/parameter APIs.",
      "ai_risk_explanation": "AI treats LDAP like SQL and uses simple string concatenation for filter construction.",
      "vulnerable_example": "ldap.search('dc=example,dc=com', { filter: '(uid=' + user + ')' })",
      "multiline": false
    },
    {
      "id": "xpath-injection",
      "name": "XPath Injection",
      "description": "XPath query built with string concatenation or interpolation. User input can modify XPath logic.",
      "severity": "critical",
      "pattern": "(?:evaluate|select|document\\.evaluate|xpath)\\s*\\([^)]*[\"'`][^\"'`]*(?:\\+[^)]+|\\$\\{[^}]+\\})",
      "fix_template": "Use parameterized XPath or validate/sanitize input. Avoid building XPath from user strings.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-643",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "XPath queries include user input via concatenation. Attackers can inject XPath to read or manipulate XML data.",
      "technical_detail": "XPath injection occurs when user input is concatenated into XPath strings. Escape special chars or use parameterized XPath APIs.",
      "ai_risk_explanation": "AI builds dynamic XPath with string concatenation when asked to query XML by user value.",
      "vulnerable_example": "document.evaluate('//user[name=\"' + userInput + '\"]', doc, null, XPathResult.ANY_TYPE, null)",
      "multiline": false
    },
    {
      "id": "ssti-template-injection",
      "name": "Server-Side Template Injection",
      "description": "Template engine render/compile called with user input. Enables remote code execution via template syntax.",
      "severity": "critical",
      "pattern": "\\.(render|compile)\\s*\\([^)]*(?:req\\.(body|query|params)|params\\.|query\\.)",
      "fix_template": "Never pass user input as template content. Use templates with named variables only; pass data as a separate context object.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-94",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User input is fed into a template engine. Attackers can inject template syntax (Handlebars, Pug, EJS) to execute server-side code.",
      "technical_detail": "SSTI occurs when user input is treated as template source. Frameworks like Handlebars, Pug, EJS can execute JS. Pass only data to templates, never raw user input as template text.",
      "ai_risk_explanation": "AI suggests passing request data to render() for dynamic pages without distinguishing template vs. data.",
      "vulnerable_example": "template.render(userInput) or pug.render(req.body.template)",
      "multiline": false
    },
    {
      "id": "path-traversal-direct",
      "name": "Path Traversal - Direct User Input",
      "description": "File path derived from user input without validation. Enables read/write of arbitrary files (e.g., ../../../etc/passwd).",
      "severity": "critical",
      "pattern": "(?:readFile|readFileSync|writeFile|writeFileSync|exists|existsSync|createReadStream|createWriteStream)\\s*\\([^)]*req\\.(body|query|params)\\b",
      "fix_template": "Validate file paths against allowed directories. Use path.resolve and ensure result stays within base path. Reject paths with .. or absolute paths from user input.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-22",
      "owasp_category": "A03:2021 - Injection",
      "category": "path_traversal",
      "message": "File operations use paths taken from user input. Attackers can use .. to escape the intended directory and access sensitive files.",
      "technical_detail": "Path traversal occurs when user input is used in fs.readFile, path.join, etc. Resolve paths and verify they remain under an allowed base directory. Reject .. and absolute paths from input.",
      "ai_risk_explanation": "AI doesn't understand path traversal and generates straightforward file access from request parameters.",
      "vulnerable_example": "fs.readFile(req.query.file) or path.join(__dirname, userInput)",
      "multiline": false
    },
    {
      "id": "path-traversal-express-static",
      "name": "Path Traversal - Express Static",
      "description": "express.static() served from user-controlled path. Can expose arbitrary directories.",
      "severity": "critical",
      "pattern": "express\\.static\\s*\\(\\s*req\\.(body|query|params)",
      "fix_template": "Use fixed, validated paths for static middleware. Never use request parameters as the root path for express.static().",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-22",
      "owasp_category": "A03:2021 - Injection",
      "category": "path_traversal",
      "message": "Static file serving uses a path from the request. Attackers can change the path to serve files from anywhere on the server.",
      "technical_detail": "express.static(root) serves files under root. If root is req.query.path, an attacker can set it to ../../../etc and read sensitive files.",
      "ai_risk_explanation": "AI may suggest dynamic static roots for multi-tenant or configurable apps without considering path traversal.",
      "vulnerable_example": "app.use(express.static(req.query.staticPath))",
      "multiline": false
    },
    {
      "id": "code-injection-eval",
      "name": "Code Injection - eval()",
      "description": "eval() or Function() called with user input. Executes arbitrary JavaScript with full process privileges.",
      "severity": "critical",
      "pattern": "(?:eval|new\\s+Function)\\s*\\([^)]*req\\.(body|query|params)\\b",
      "fix_template": "Remove eval/Function with user input. Use a safe parser (e.g., JSON.parse for data) or a sandboxed expression evaluator if dynamic evaluation is required.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-95",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User input is executed as JavaScript via eval or Function. Attackers can run any code on the server.",
      "technical_detail": "eval() and new Function() execute strings as code. Never pass user input. For JSON, use JSON.parse. For expressions, use a restricted evaluator.",
      "ai_risk_explanation": "AI suggests eval() for 'dynamic' behavior without security consideration, especially when asked to evaluate expressions from input.",
      "vulnerable_example": "eval(req.body.code) or Function(userInput)()",
      "multiline": false
    },
    {
      "id": "prototype-pollution",
      "name": "Prototype Pollution",
      "description": "Object.assign or spread with user-controlled object. Can pollute Object.prototype and affect application logic.",
      "severity": "critical",
      "pattern": "(?:Object\\.assign|\\{\\s*\\.\\.\\.)\\s*\\(?[^)]*JSON\\.parse\\s*\\([^)]*req\\.(body|query|params)\\b",
      "fix_template": "Validate parsed JSON structure; reject __proto__, constructor, or nested prototype keys. Use a safe merge or copy only known whitelisted properties.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-1321",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User-provided JSON is merged into objects without validation. Attackers can inject __proto__ or constructor to modify global object behavior.",
      "technical_detail": "Prototype pollution: merging {\"__proto__\": {\"isAdmin\": true}} can alter Object.prototype. Validate keys, reject __proto__/constructor, and use safe merge (e.g., object without prototype).",
      "ai_risk_explanation": "AI uses Object.assign or spread for merging config without validating against prototype pollution payloads.",
      "vulnerable_example": "Object.assign(config, JSON.parse(req.body.settings))",
      "multiline": false
    },
    {
      "id": "missing-auth-middleware-express",
      "name": "Missing Authentication Middleware - Express Routes",
      "description": "Express routes (GET, POST, PUT, DELETE) for sensitive paths without authentication middleware. API endpoints may be accessible to unauthenticated users.",
      "severity": "critical",
      "pattern": "app\\.(get|post|put|delete|patch)\\s*\\(\\s*['\"`][^'\"]*/(api/)?(admin|users|settings|config)",
      "fix_template": "Add authentication middleware: app.get('/api/admin/...', authenticate, handler) or use router-level auth with app.use('/api/admin', authenticate, adminRouter)",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-306",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "authentication",
      "message": "Sensitive API routes are defined without authentication middleware. Unauthenticated attackers can access admin, user, or config endpoints.",
      "technical_detail": "Express routes must include authentication middleware (e.g., passport.authenticate, JWT verify, session check) before handlers for protected paths. Without it, any client can call these endpoints.",
      "ai_risk_explanation": "AI generates functional routes but omits authentication as an 'extra step'—focusing on request handling rather than access control.",
      "vulnerable_example": "app.get('/api/admin/users', (req, res) => { ... })",
      "multiline": false
    },
    {
      "id": "missing-auth-nextjs-api",
      "name": "Missing Authentication - Next.js API Routes",
      "description": "Next.js API routes in pages/api/ or app/api/ export handlers without authentication validation. Handlers may execute without verifying the user.",
      "severity": "critical",
      "pattern": "(export default|module\\.exports\\s*=)\\s*(async\\s+)?(function|const\\s+\\w+\\s*=\\s*(?:async\\s+)?)\\s*\\([^)]*req\\s*,",
      "fix_template": "Add auth at the start of the handler: const session = await getServerSession(req, res, authOptions); if (!session) return res.status(401).json({ error: 'Unauthorized' })",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-306",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "authentication",
      "message": "API route handlers are exported without authentication checks. Unauthenticated requests can access protected logic and data.",
      "technical_detail": "Next.js API routes must explicitly validate the session (getServerSession, getToken) or JWT before processing. Exporting a handler without an auth check allows anonymous access.",
      "ai_risk_explanation": "AI generates Next.js API handlers that fulfill the request/response contract but treats authentication as an optional add-on, not a requirement.",
      "vulnerable_example": "export default async function handler(req, res) { const data = await db.query(...); return res.json(data) }",
      "multiline": false
    },
    {
      "id": "jwt-without-expiration",
      "name": "JWT Without Expiration",
      "description": "jwt.sign() called without expiresIn option. Tokens never expire, allowing indefinite reuse if leaked.",
      "severity": "high",
      "pattern": "jwt\\.sign\\s*\\([^,]+,\\s*[^,)]+\\s*\\)",
      "fix_template": "Add expiration: jwt.sign(payload, secret, { expiresIn: '1h' }) or { expiresIn: '7d' }",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-613",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "authentication",
      "message": "JWT tokens are signed without an expiration claim. Stolen tokens remain valid forever and cannot be invalidated without changing the secret.",
      "technical_detail": "jwt.sign(payload, secret) omits the options object with expiresIn. Always set expiresIn (e.g., '15m', '1h', '7d') to limit token lifetime.",
      "ai_risk_explanation": "AI generates minimal jwt.sign() calls with payload and secret, omitting expiration as non-essential to 'making it work'.",
      "vulnerable_example": "jwt.sign(payload, secret)",
      "multiline": false
    },
    {
      "id": "weak-session-configuration",
      "name": "Weak Session Configuration",
      "description": "express-session configured with weak or insecure settings: short secret, resave: true, missing secure/httpOnly cookie flags.",
      "severity": "high",
      "pattern": "session\\s*\\(\\s*\\{[^}]*secret\\s*:\\s*['\"][^'\"]{1,20}['\"]",
      "fix_template": "Use strong secret from env, set cookie: { secure: true, httpOnly: true, sameSite: 'strict' }, resave: false, saveUninitialized: false",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-613",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "authentication",
      "message": "Session configuration uses a weak or short secret and may lack secure cookie flags. Sessions can be hijacked or forged.",
      "technical_detail": "Weak secrets are guessable. Missing httpOnly allows XSS to steal cookies; missing secure allows transmission over HTTP. Use process.env.SESSION_SECRET with sufficient entropy.",
      "ai_risk_explanation": "AI provides minimal session() config with placeholder secrets and default flags, not production-hardened settings.",
      "vulnerable_example": "session({ secret: 'easy', resave: true })",
      "multiline": false
    },
    {
      "id": "hardcoded-session-secret",
      "name": "Hardcoded Session Secret",
      "description": "Session or JWT secret hardcoded in source code instead of using environment variables. Exposed in repos and builds.",
      "severity": "critical",
      "pattern": "secret\\s*:\\s*['\"](?:keyboard-cat|dev|secret|changeme|password|12345|mysecret|session-secret|jwt-secret)['\"]",
      "fix_template": "Use environment variable: secret: process.env.SESSION_SECRET. Ensure SESSION_SECRET is set in deployment and never committed.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "authentication",
      "message": "Session or JWT secret is hardcoded. If the code is leaked, attackers can forge sessions and impersonate any user.",
      "technical_detail": "Hardcoded secrets appear in version control, logs, and bundled assets. Use process.env for all secrets and rotate them if exposed.",
      "ai_risk_explanation": "AI uses example or placeholder secrets (e.g., 'keyboard-cat') without indicating they must be replaced with env vars.",
      "vulnerable_example": "secret: \"keyboard-cat\"",
      "multiline": false
    },
    {
      "id": "missing-authorization-check",
      "name": "Missing Authorization Check",
      "description": "Endpoints that modify or delete data without verifying the current user is authorized (e.g., DELETE /api/users/:id without ownership check).",
      "severity": "critical",
      "pattern": "(app|router)\\.(delete|put|patch)\\s*\\([^)]*['\"`][^'\"]*/api/users",
      "fix_template": "Verify ownership before mutating: if (req.user.id !== req.params.id && !req.user.isAdmin) return res.status(403).json({ error: 'Forbidden' })",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-639",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authorization",
      "message": "State-changing endpoints for user resources do not check if the requester is authorized to modify the target. Any authenticated user may modify others' data.",
      "technical_detail": "Authorization must verify that the authenticated user owns the resource or has the required role before allowing updates or deletions.",
      "ai_risk_explanation": "AI implements the mutation logic (e.g., delete user by ID) without adding ownership or role checks, treating auth as sufficient.",
      "vulnerable_example": "router.delete('/api/users/:id', async (req, res) => { await User.deleteOne({ _id: req.params.id }) })",
      "multiline": false
    },
    {
      "id": "idor-direct-object-reference",
      "name": "Insecure Direct Object Reference (IDOR)",
      "description": "Using req.params.id or req.query.id directly in database lookups without verifying the user is authorized to access that resource.",
      "severity": "critical",
      "pattern": "\\.(findById|findOne|findOneAndUpdate|updateOne|deleteOne)\\s*\\(\\s*req\\.(params|query)\\.\\w+",
      "fix_template": "Verify ownership: const resource = await Model.findById(req.params.id); if (!resource || resource.userId !== req.user.id) return res.status(404).json({ error: 'Not found' })",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-639",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authorization",
      "message": "Resource IDs from the request are used directly in queries without authorization. Attackers can access or modify any record by guessing or enumerating IDs.",
      "technical_detail": "IDOR occurs when object identifiers from user input are trusted. Always fetch the resource, then check that the current user owns it or has permission before returning or mutating.",
      "ai_risk_explanation": "AI maps req.params.id to findById() as the obvious implementation, skipping the authorization step.",
      "vulnerable_example": "User.findById(req.params.id)",
      "multiline": false
    },
    {
      "id": "admin-endpoints-without-role-check",
      "name": "Admin Endpoints Without Role Check",
      "description": "Routes under /admin or /api/admin without role verification. Authenticated non-admin users may access admin-only functionality.",
      "severity": "critical",
      "pattern": "(app|router)\\.(get|post|put|delete|patch)\\s*\\(\\s*['\"`][^'\"]*/(admin|api/admin)",
      "fix_template": "Add role check: if (!req.user?.isAdmin) return res.status(403).json({ error: 'Forbidden' }). Or use requireAdmin middleware.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-639",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authorization",
      "message": "Admin routes are protected by authentication but not by role. Any logged-in user can perform admin actions.",
      "technical_detail": "Authentication confirms identity; authorization must confirm the user has the admin role. Add a role check (isAdmin, role === 'admin') before admin logic.",
      "ai_risk_explanation": "AI secures admin routes with auth middleware but omits role checks, assuming 'admin path' implies admin-only access.",
      "vulnerable_example": "app.get('/admin/users', authenticate, (req, res) => { ... })",
      "multiline": false
    },
    {
      "id": "missing-csrf-protection",
      "name": "Missing CSRF Protection",
      "description": "State-changing endpoints (POST, PUT, DELETE) without CSRF token validation. Cross-site requests can trigger actions on behalf of authenticated users.",
      "severity": "high",
      "pattern": "(app|router)\\.(post|put|delete|patch)\\s*\\([^)]*['\"`][^'\"]*",
      "fix_template": "Add CSRF middleware: app.use(csrf({ cookie: true })) and validate token from header or body on state-changing routes.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-352",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authorization",
      "message": "State-changing routes accept requests without CSRF tokens. Attackers can craft malicious sites that submit forms or requests when the victim is logged in.",
      "technical_detail": "CSRF exploits the browser's automatic sending of cookies. Use SameSite cookies, double-submit cookie, or synchronizer token pattern to validate request origin.",
      "ai_risk_explanation": "AI implements POST/PUT/DELETE handlers without CSRF, as it is often omitted from tutorials and 'getting started' examples.",
      "vulnerable_example": "app.post('/api/transfer', (req, res) => { ... })",
      "multiline": false
    },
    {
      "id": "graphql-resolver-without-auth",
      "name": "GraphQL Resolver Without Auth",
      "description": "GraphQL resolvers (especially mutations) that modify data without checking context.user or context.auth. Unauthenticated or unauthorized callers can mutate data.",
      "severity": "critical",
      "pattern": "(Mutation|Query)\\s*:\\s*\\{[^}]*(?:async\\s+)?\\([^)]*\\)\\s*=>\\s*\\{[^}]*\\.[a-zA-Z]+\\s*\\([^)]*args\\b",
      "fix_template": "Check context at resolver start: if (!context.user) throw new Error('Unauthorized'); for mutations, also verify context.user has permission for the resource.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-306",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authorization",
      "message": "GraphQL resolvers perform data operations without validating context.user. Mutations can be called by unauthenticated clients or without resource-level authorization.",
      "technical_detail": "Every resolver that reads or writes sensitive data must verify context.user (or context.auth). Mutations should also enforce resource ownership or role checks.",
      "ai_risk_explanation": "AI generates resolvers that focus on the data layer (prisma.create, db.update) and treat authentication as separate or handled elsewhere.",
      "vulnerable_example": "createUser: async (parent, args) => prisma.user.create({ data: args })",
      "multiline": true
    },
    {
      "id": "weak-hashing-md5",
      "name": "Weak Hashing - MD5",
      "description": "MD5 is cryptographically broken; do not use for passwords, tokens, or integrity. Use SHA-256 or stronger, or Argon2/bcrypt for passwords.",
      "severity": "critical",
      "pattern": "createHash\\s*\\(\\s*['\"]md5['\"]\\)|md5\\s*\\(",
      "fix_template": "Use crypto.createHash('sha256') for general hashing, or bcrypt/argon2 for passwords. Never use MD5 for security-sensitive data.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-327",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "MD5 is used for hashing. MD5 is cryptographically broken and unsuitable for passwords, tokens, or integrity checks. Attackers can forge collisions.",
      "technical_detail": "MD5 has known collision vulnerabilities. Replace with SHA-256 (or SHA-3) for general hashing, and use bcrypt or Argon2 for password hashing.",
      "ai_risk_explanation": "AI suggests MD5 because it appears in older tutorials and examples.",
      "vulnerable_example": "crypto.createHash('md5') or md5(password)",
      "multiline": false
    },
    {
      "id": "weak-hashing-sha1",
      "name": "Weak Hashing - SHA1",
      "description": "SHA1 is deprecated for security use. Use SHA-256 or SHA-3 for integrity and hashing.",
      "severity": "high",
      "pattern": "createHash\\s*\\(\\s*['\"]sha1['\"]\\)",
      "fix_template": "Use crypto.createHash('sha256') or 'sha384'/'sha512'. Prefer SHA-256 or stronger for any security-sensitive hashing.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-327",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "SHA1 is used for hashing. SHA1 is deprecated and has known collision attacks. Do not use for security-sensitive purposes.",
      "technical_detail": "SHA1 collision attacks are practical. Migrate to SHA-256 or SHA-3 for all security-related hashing.",
      "ai_risk_explanation": "AI suggests MD5 because it appears in older tutorials and examples; SHA1 appears in the same legacy examples.",
      "vulnerable_example": "crypto.createHash('sha1')",
      "multiline": false
    },
    {
      "id": "insecure-random-math-random",
      "name": "Insecure Random - Math.random for Security",
      "description": "Math.random() is predictable and must not be used for tokens, IDs, or any security purpose. Use crypto.randomBytes or crypto.randomInt.",
      "severity": "high",
      "pattern": "Math\\.random\\s*\\(\\s*\\)",
      "fix_template": "Use crypto.randomBytes(n).toString('hex') for tokens, or crypto.randomInt(min, max) for integers. Never use Math.random() for security.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-338",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "Math.random() is used; it is predictable and must not be used for tokens, session IDs, or cryptographic purposes.",
      "technical_detail": "Math.random() is not cryptographically secure. Use crypto.randomBytes() or crypto.randomInt() for any security-sensitive randomness.",
      "ai_risk_explanation": "AI uses Math.random() as the 'simple' solution for randomness.",
      "vulnerable_example": "const token = Math.random().toString(36).slice(2)",
      "multiline": false
    },
    {
      "id": "hardcoded-encryption-key",
      "name": "Hardcoded Encryption Key",
      "description": "Encryption keys must not be hardcoded in source. Use environment variables or a secrets manager and key derivation (e.g., scrypt).",
      "severity": "critical",
      "pattern": "createCipher(?:iv)?\\s*\\([^)]*['\"][^'\"]{8,}['\"]",
      "fix_template": "Load key from process.env or secrets manager; use crypto.scrypt or crypto.pbkdf2 to derive keys from a secret. Never commit keys to source.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-321",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "Encryption key is hardcoded in source. Keys in source are exposed in repos and builds; use environment variables or a secrets manager.",
      "technical_detail": "Hardcoded keys are visible to anyone with code access. Use env vars or a secret store and key derivation (scrypt/pbkdf2) where appropriate.",
      "ai_risk_explanation": "AI demonstrates encryption with literal keys to make examples runnable, leading to hardcoded keys in real code.",
      "vulnerable_example": "crypto.createCipher('aes-256-cbc', 'hardcoded-key')",
      "multiline": false
    },
    {
      "id": "predictable-iv",
      "name": "Predictable IV (Initialization Vector)",
      "description": "IVs must be random and unique per encryption; reusing or using predictable IVs breaks confidentiality. Generate with crypto.randomBytes for each encrypt.",
      "severity": "critical",
      "pattern": "iv\\s*=\\s*Buffer\\.from\\s*\\(\\s*['\"][^'\"]*['\"]\\)|const\\s+iv\\s*=\\s*['\"][^'\"]+['\"]",
      "fix_template": "Generate IV per encryption: const iv = crypto.randomBytes(16); pass iv to createCipheriv and store/prepend iv with ciphertext (IV can be public, but must be unique and random).",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-329",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "IV is fixed or predictable. Reusing or predictable IVs can leak plaintext; IV must be random and unique per encryption.",
      "technical_detail": "Block ciphers require a unique, random IV per encryption. Use crypto.randomBytes(16) for AES and prepend IV to ciphertext if needed.",
      "ai_risk_explanation": "AI uses fixed IVs in examples (e.g. Buffer.from('1234...')) to keep code simple, which is insecure in production.",
      "vulnerable_example": "const iv = Buffer.from('1234567890123456')",
      "multiline": false
    },
    {
      "id": "custom-crypto-implementation",
      "name": "Custom Crypto Implementation",
      "description": "Do not implement custom encryption (xor, rot13, hand-rolled AES). Use standard libraries (crypto.createCipheriv, TLS) to avoid subtle flaws.",
      "severity": "high",
      "pattern": "\\b(xor|rot13|caesar)\\s*\\(.*(encrypt|decrypt)|function\\s+(encrypt|decrypt)\\s*\\([^)]*\\)\\s*\\{[^}]*[+^%]",
      "fix_template": "Use Node crypto: crypto.createCipheriv/createDecipheriv with AES-256-GCM or ChaCha20-Poly1305. Do not roll your own cipher.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-327",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "Custom or non-standard encryption is used. Custom crypto is error-prone and often weak; use proven libraries (e.g. Node crypto module).",
      "technical_detail": "Custom encryption (xor, rot13, or hand-rolled algorithms) lacks proper security analysis. Use crypto.createCipheriv with AES-256-GCM or similar.",
      "ai_risk_explanation": "AI 'creates' crypto when asked to encrypt without using proven libraries.",
      "vulnerable_example": "function encrypt(s, key) { return s.split('').map(c => c.charCodeAt(0) ^ key).join(''); }",
      "multiline": true
    },
    {
      "id": "disabled-tls-verification",
      "name": "Disabled TLS Verification",
      "description": "Disabling TLS certificate verification (rejectUnauthorized: false or NODE_TLS_REJECT_UNAUTHORIZED=0) allows man-in-the-middle attacks. Fix certs or use proper CA instead.",
      "severity": "critical",
      "pattern": "rejectUnauthorized\\s*:\\s*false|NODE_TLS_REJECT_UNAUTHORIZED\\s*=\\s*['\"]?0['\"]?",
      "fix_template": "Remove rejectUnauthorized: false. Fix server certificates or add the proper CA; use NODE_EXTRA_CA_CERTS for custom CAs. Never disable verification in production.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-295",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "configuration",
      "message": "TLS certificate verification is disabled. This allows man-in-the-middle attacks; always verify server identity in production.",
      "technical_detail": "rejectUnauthorized: false or NODE_TLS_REJECT_UNAUTHORIZED=0 disables certificate validation. Attackers can intercept and modify TLS traffic.",
      "ai_risk_explanation": "AI disables verification to 'make it work' during development.",
      "vulnerable_example": "rejectUnauthorized: false or NODE_TLS_REJECT_UNAUTHORIZED=0",
      "multiline": false
    },
    {
      "id": "weak-cipher-selection",
      "name": "Weak Cipher Selection",
      "description": "DES, 3DES, RC4 and other deprecated ciphers are weak or broken. Use AES-256-GCM, ChaCha20-Poly1305, or current TLS cipher suites.",
      "severity": "high",
      "pattern": "createCipher(?:iv)?\\s*\\(\\s*['\"](?:DES|3DES|DES-EDE|RC4|rc4|des|blowfish)['\"]|ciphers?\\s*[:=]\\s*['\"].*\\b(DES|3DES|RC4|rc4)\\b",
      "fix_template": "Use AES-256-GCM or ChaCha20-Poly1305 via crypto.createCipheriv. For TLS, rely on default secure ciphers; avoid DES, 3DES, RC4.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-327",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "A deprecated or weak cipher (DES, 3DES, RC4) is used. These ciphers are broken or weak; use AES-256 or modern AEAD ciphers.",
      "technical_detail": "DES/3DES have small key sizes; RC4 is biased. Use AES-256-GCM or ChaCha20-Poly1305 for symmetric encryption.",
      "ai_risk_explanation": "AI suggests deprecated ciphers from older documentation or examples.",
      "vulnerable_example": "crypto.createCipher('des-ede3-cbc', key, iv)",
      "multiline": false
    },
    {
      "id": "hardcoded-api-key",
      "name": "Hardcoded API Key",
      "description": "API keys must not be hardcoded in source. Use environment variables or a secrets manager; never commit keys to version control.",
      "severity": "critical",
      "pattern": "(?:API_KEY|APIKEY|api_key|apiKey)\\s*[:=]\\s*['\"][^'\"]{8,}['\"]|['\"](?:sk-|pk_live_|pk_test_)[^'\"]*['\"]",
      "fix_template": "Use process.env.API_KEY or a secrets manager. Load at runtime; never commit. Rotate any exposed keys immediately.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "API key is hardcoded in source. Exposed keys can be extracted from repos or builds; use environment variables or a secret store.",
      "technical_detail": "Hardcoded API keys are visible in code and often leaked via Git. Use env vars or a secrets manager and rotate if exposed.",
      "ai_risk_explanation": "AI includes API keys in examples to make code 'complete' and runnable.",
      "vulnerable_example": "const API_KEY = \"sk-...\" or apiKey: \"pk_live_...\"",
      "multiline": false
    },
    {
      "id": "hardcoded-password",
      "name": "Hardcoded Password",
      "description": "Passwords must not be hardcoded. Use environment variables, secrets managers, or secure credential storage; never commit passwords.",
      "severity": "critical",
      "pattern": "(?:password|PASSWORD)\\s*[:=]\\s*['\"][^'\"]+['\"]",
      "fix_template": "Use process.env.PASSWORD or a secrets manager. Store hashes (bcrypt/Argon2) for user passwords; never store or log plaintext passwords.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "Password is hardcoded in source. Anyone with code access can use it; use env vars or a secret store and rotate if exposed.",
      "technical_detail": "Hardcoded passwords are a common cause of breaches. Load from environment or secrets manager; never commit to version control.",
      "ai_risk_explanation": "AI uses placeholder passwords in examples (e.g. 'admin123') which get copied into real configs.",
      "vulnerable_example": "password: \"admin123\" or const PASSWORD = \"...\"",
      "multiline": false
    },
    {
      "id": "hardcoded-jwt-secret",
      "name": "Hardcoded JWT Secret",
      "description": "JWT signing secret must not be a string literal in source. Use a strong secret from environment or secrets manager.",
      "severity": "critical",
      "pattern": "jwt\\.sign\\s*\\([^,]+,\\s*['\"][^'\"]+['\"]",
      "fix_template": "Use process.env.JWT_SECRET or a secrets manager for the signing key. Use strong, random secrets (e.g. 256-bit); never hardcode.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "JWT secret is hardcoded. Attackers with source access can forge tokens; use a strong secret from env or secret store.",
      "technical_detail": "JWT signatures are verified with the same secret. A hardcoded secret allows token forgery. Use env var with high entropy.",
      "ai_risk_explanation": "AI uses simple strings to demonstrate JWT functionality.",
      "vulnerable_example": "jwt.sign(payload, \"secret-key\")",
      "multiline": false
    },
    {
      "id": "aws-credentials-in-code",
      "name": "AWS Credentials in Code",
      "description": "AWS access keys must not be hardcoded. Use IAM roles, environment variables, or credential profiles; never commit accessKeyId/secretAccessKey.",
      "severity": "critical",
      "pattern": "accessKeyId\\s*:\\s*['\"]AKIA[^'\"]*['\"]|secretAccessKey\\s*:\\s*['\"][^'\"]+['\"]",
      "fix_template": "Use default credential chain (env vars, ~/.aws/credentials, or IAM role). For Lambda/ECS use IAM roles; never put keys in source.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "AWS credentials are hardcoded. Exposed keys grant full access to your AWS account; use IAM roles or env vars and rotate if leaked.",
      "technical_detail": "Hardcoded accessKeyId/secretAccessKey are frequently leaked via Git. Use IAM roles or env vars and never commit credentials.",
      "ai_risk_explanation": "AI pastes AWS credential placeholders (AKIA...) into examples, which may be committed.",
      "vulnerable_example": "accessKeyId: \"AKIA...\", secretAccessKey: \"...\"",
      "multiline": false
    },
    {
      "id": "database-credentials-in-code",
      "name": "Database Credentials in Code",
      "description": "Database connection strings with embedded passwords must not be in source. Use environment variables or a secrets manager.",
      "severity": "critical",
      "pattern": "(?:mongodb|postgres|mysql|postgresql)://[^'\"\\s]*:[^'\"\\s@]+@",
      "fix_template": "Load connection URL from process.env.DATABASE_URL or similar. Never embed passwords; use secret store or env-specific config.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "Database credentials are embedded in connection string. Source control and builds expose them; use env vars or secrets manager.",
      "technical_detail": "Connection strings with passwords in code are easily leaked. Use DATABASE_URL from environment or inject credentials at runtime.",
      "ai_risk_explanation": "AI provides full connection strings in examples (e.g. mongodb://user:pass@host) for convenience.",
      "vulnerable_example": "mongodb://admin:password@localhost/db",
      "multiline": false
    },
    {
      "id": "private-keys-in-code",
      "name": "Private Keys in Code",
      "description": "Private keys (SSH, RSA, certificates) must not be embedded as string literals. Use files, env vars, or secrets manager and restrict file permissions.",
      "severity": "critical",
      "pattern": "-----BEGIN\\s+(?:RSA\\s+)?PRIVATE KEY-----|-----BEGIN\\s+.*PRIVATE",
      "fix_template": "Load keys from files (e.g. fs.readFileSync) or secrets manager; use env var for PEM string only if necessary. Restrict key file permissions.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "Private key is embedded in source. Keys in code are exposed in repos; load from secure storage and restrict access.",
      "technical_detail": "Embedded private keys are exposed in version control and builds. Store in files with strict permissions or use a secrets manager.",
      "ai_risk_explanation": "AI inlines key PEMs in examples to avoid file I/O, leading to committed keys.",
      "vulnerable_example": "const key = `-----BEGIN RSA PRIVATE KEY-----...`",
      "multiline": true
    },
    {
      "id": "secrets-env-default",
      "name": "Secrets in Environment Object Construction",
      "description": "Providing a default fallback for secrets (e.g. process.env.API_KEY || 'default-key') defeats env-based configuration and can leak default credentials.",
      "severity": "high",
      "pattern": "process\\.env\\.\\w+\\s*\\|\\|\\s*['\"][^'\"]+['\"]",
      "fix_template": "Use process.env.API_KEY without a default, or fail at startup if missing: if (!process.env.API_KEY) throw new Error('API_KEY required'). Never default to a literal secret.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "Environment variable has a default literal value. Defaults can expose a fixed secret when env is unset (e.g. in CI or new deployments).",
      "technical_detail": "Patterns like process.env.API_KEY || 'default-key' mean missing env falls back to a committed secret. Require env to be set or fail fast.",
      "ai_risk_explanation": "AI provides defaults that defeat the purpose of env vars.",
      "vulnerable_example": "{ apiKey: process.env.API_KEY || \"default-key\" }",
      "multiline": false
    },
    {
      "id": "debug-mode-in-production",
      "name": "Debug Mode in Production",
      "description": "Application configured for development/debug mode in production. Exposes stack traces, verbose logs, and internal details.",
      "severity": "high",
      "pattern": "app\\.set\\s*\\(\\s*['\"]env['\"]\\s*,\\s*['\"]development['\"]|DEBUG\\s*=\\s*['\"]?true['\"]?|NODE_ENV\\s*=\\s*['\"]development['\"]",
      "fix_template": "Use process.env.NODE_ENV === 'production' and set NODE_ENV=production in deployment. Never hardcode development or DEBUG=true for production.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-489",
      "owasp_category": "A04:2021 - Insecure Design",
      "category": "configuration",
      "message": "Debug or development mode is enabled. This exposes internal details, stack traces, and verbose errors to attackers.",
      "technical_detail": "Development mode disables optimizations and exposes debugging information. Always use NODE_ENV=production and ensure no DEBUG=true or env='development' in production config.",
      "ai_risk_explanation": "AI uses development configs because that's what works in tutorials and examples.",
      "vulnerable_example": "app.set('env', 'development') or DEBUG=true",
      "multiline": false
    },
    {
      "id": "cors-wildcard-origin",
      "name": "CORS Wildcard Origin",
      "description": "CORS configured with wildcard origin (*) allows any site to make credentialed requests. Enables cross-origin abuse.",
      "severity": "high",
      "pattern": "cors\\s*\\(\\s*\\{[^}]*origin\\s*:\\s*['\"]\\*['\"]|Access-Control-Allow-Origin\\s*:\\s*['\"]\\*['\"]|origin\\s*:\\s*true\\b",
      "fix_template": "Use specific origins: cors({ origin: ['https://yourdomain.com'] }) or validate Origin header against an allowlist. Never use '*' for credentials.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-942",
      "owasp_category": "A05:2021 - Security Misconfiguration",
      "category": "configuration",
      "message": "CORS allows any origin (*). Attackers can make cross-origin requests from malicious sites to your API with user credentials.",
      "technical_detail": "Wildcard CORS origin permits any domain to send requests. With credentials, cookies and auth headers are sent. Use an explicit allowlist of trusted origins.",
      "ai_risk_explanation": "AI enables CORS with wildcard to avoid 'CORS errors' during development.",
      "vulnerable_example": "cors({ origin: '*' }) or Access-Control-Allow-Origin: *",
      "multiline": false
    },
    {
      "id": "binding-to-all-interfaces",
      "name": "Binding to 0.0.0.0 Without Firewall",
      "description": "Application binds to 0.0.0.0, exposing it on all network interfaces. Requires firewall/network isolation; otherwise exposes service to local network or internet.",
      "severity": "medium",
      "pattern": "\\.listen\\s*\\([^,)]+,\\s*['\"]0\\.0\\.0\\.0['\"]|host\\s*:\\s*['\"]0\\.0\\.0\\.0['\"]",
      "fix_template": "Use localhost (127.0.0.1) for local dev. For production, ensure firewall restricts access; use reverse proxy (nginx) in front; avoid 0.0.0.0 unless required and network is secured.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-284",
      "owasp_category": "A05:2021 - Security Misconfiguration",
      "category": "configuration",
      "message": "Binding to 0.0.0.0 exposes the app on all interfaces. Without proper firewall, the service may be reachable from the network or internet.",
      "technical_detail": "0.0.0.0 binds to all interfaces. In containers or VMs this may be intended, but on a host it can expose the app. Ensure network segmentation or firewall rules restrict access.",
      "ai_risk_explanation": "AI suggests 0.0.0.0 to make the app reachable in Docker or across devices without considering network exposure.",
      "vulnerable_example": "app.listen(3000, '0.0.0.0')",
      "multiline": false
    },
    {
      "id": "missing-helmet-security-headers",
      "name": "Missing Security Headers - No Helmet",
      "description": "Express app uses security-related middleware but helmet() is not applied. Missing CSP, X-Frame-Options, HSTS, and other security headers.",
      "severity": "high",
      "pattern": "(?:require|import)\\s*\\(?\\s*['\"]express['\"]\\s*\\)?|from\\s+['\"]express['\"]",
      "fix_template": "Add helmet middleware: const helmet = require('helmet'); app.use(helmet()); Optionally configure contentSecurityPolicy, hsts, etc.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-693",
      "owasp_category": "A05:2021 - Security Misconfiguration",
      "category": "configuration",
      "message": "Express apps should use helmet() to set security headers (CSP, X-Frame-Options, HSTS, X-Content-Type-Options). Without them, apps are vulnerable to clickjacking, MIME sniffing, and similar attacks.",
      "technical_detail": "Helmet sets X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security, Content-Security-Policy, and more. Add app.use(helmet()) early in the middleware chain.",
      "ai_risk_explanation": "AI focuses on routing and business logic, not defense-in-depth; helmet is often omitted from starter templates.",
      "vulnerable_example": "const app = require('express')(); app.get('/', ...)",
      "multiline": false
    },
    {
      "id": "missing-rate-limiting",
      "name": "Missing Rate Limiting on Sensitive Endpoints",
      "description": "Authentication or sensitive endpoints (login, signup, password reset) without rate limiting. Enables brute-force and DoS attacks.",
      "severity": "high",
      "pattern": "(app|router)\\.(post|get)\\s*\\([^)]*['\"`](/login|/signin|/auth|/signup|/register|/password-reset|/forgot-password)",
      "fix_template": "Add rate limiting: app.use('/login', rateLimit({ windowMs: 15 * 60 * 1000, max: 5 })). Use express-rate-limit or similar.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-770",
      "owasp_category": "A04:2021 - Insecure Design",
      "category": "configuration",
      "message": "Sensitive auth endpoints lack rate limiting. Attackers can brute-force passwords, enumerate users, or DoS the service.",
      "technical_detail": "Rate limiting (e.g., 5 attempts per 15 minutes on login) prevents brute-force. Use express-rate-limit or similar middleware on auth and sensitive routes.",
      "ai_risk_explanation": "AI focuses on functionality, not DoS protection; rate limiters are rarely included in auth tutorials.",
      "vulnerable_example": "app.post('/login', (req, res) => { ... })",
      "multiline": false
    },
    {
      "id": "verbose-error-messages",
      "name": "Verbose Error Messages Exposed",
      "description": "Full error stack traces or details sent to client. Reveals file paths, internals, and library versions to attackers.",
      "severity": "high",
      "pattern": "res\\.(send|json)\\s*\\([^)]*error\\.(stack|message)|send\\s*\\([^)]*err\\.stack|\\.send\\([^)]*Error\\.stack",
      "fix_template": "Log errors server-side; return generic messages to client: res.status(500).json({ error: 'Internal server error' }). Never send error.stack or full error objects.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-209",
      "owasp_category": "A04:2021 - Insecure Design",
      "category": "configuration",
      "message": "Error stack traces or detailed messages are sent to the client. Attackers can learn about file structure, dependencies, and exploit paths.",
      "technical_detail": "error.stack reveals paths, line numbers, and internal logic. Log to server; return a generic message to clients. Use centralized error handling middleware.",
      "ai_risk_explanation": "AI includes detailed errors for 'debugging convenience' without distinguishing development vs. production behavior.",
      "vulnerable_example": "res.status(500).send(error.stack)",
      "multiline": false
    },
    {
      "id": "sql-errors-exposed-to-client",
      "name": "SQL Errors Exposed to Client",
      "description": "Raw database or SQL errors returned in HTTP responses. Leaks schema, queries, and database structure to attackers.",
      "severity": "high",
      "pattern": "res\\.(send|json)\\s*\\([^)]*err\\.message|json\\s*\\([^)]*\\{\\s*error\\s*:\\s*err\\.(message|sql)|\\.send\\([^)]*db\\.error",
      "fix_template": "Log database errors; return generic 500 to client. Never expose err.message, err.sql, or raw DB errors. Use error codes internally, not in responses.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-209",
      "owasp_category": "A04:2021 - Insecure Design",
      "category": "configuration",
      "message": "Database errors (messages, SQL, codes) are returned to the client. Attackers can infer schema and craft SQL injection payloads.",
      "technical_detail": "Exposing err.message or err.sql reveals table names, column structure, and query logic. Log server-side; return generic error to client.",
      "ai_risk_explanation": "AI returns error objects directly for quick debugging, without sanitizing for production.",
      "vulnerable_example": "res.status(500).json({ error: err.message })",
      "multiline": false
    },
    {
      "id": "disabled-security-features",
      "name": "Disabled Security Features",
      "description": "Comments or code disabling security linters, SQL injection warnings, or other security checks. Indicates intentional bypass of safeguards.",
      "severity": "medium",
      "pattern": "//\\s*eslint-disable(?:-next-line)?\\s+.*security|//\\s*@ts-ignore|//\\s*nosonar|\\/\\*\\s*eslint-disable.*security",
      "fix_template": "Address the underlying issue instead of disabling. Fix the vulnerability; do not suppress security rules.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-489",
      "owasp_category": "A05:2021 - Security Misconfiguration",
      "category": "configuration",
      "message": "Security-related lint rules or checks are disabled. This may hide real vulnerabilities such as SQL injection or XSS.",
      "technical_detail": "Disabling security/detect-sql-injection, security/detect-object-injection, or similar rules suppresses valid warnings. Fix the root cause instead.",
      "ai_risk_explanation": "AI suggests disabling linters when they flag code that 'works' but is insecure, to avoid build failures.",
      "vulnerable_example": "// eslint-disable-next-line security/detect-sql-injection",
      "multiline": false
    },
    {
      "id": "xss-innerhtml-user-input",
      "name": "XSS - innerHTML with User Input",
      "description": "innerHTML assigned with user-controlled data. Enables script injection; attacker can steal cookies or modify page content.",
      "severity": "critical",
      "pattern": "\\.innerHTML\\s*=\\s*(?:`[^`]*\\$\\{|[^=]+\\+)|innerHTML\\s*=\\s*[^;]*(?:userInput|req\\.|params\\.|query\\.)",
      "fix_template": "Use textContent for plain text, or sanitize with DOMPurify.sanitize(userInput) before assigning to innerHTML. Never assign unsanitized user input to innerHTML.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-79",
      "owasp_category": "A03:2021 - Injection",
      "category": "xss",
      "message": "User input is assigned to innerHTML. Attackers can inject <script> or event handlers to execute JavaScript in the victim's browser.",
      "technical_detail": "innerHTML parses and executes HTML/JS. User input with <script> or onclick= runs in the page context. Use textContent or sanitize with DOMPurify.",
      "ai_risk_explanation": "AI uses innerHTML as the 'easy way' to update DOM and display dynamic content.",
      "vulnerable_example": "element.innerHTML = userInput or element.innerHTML = `${userInput}`",
      "multiline": false
    },
    {
      "id": "xss-dangerouslysetinnerhtml-react",
      "name": "XSS - dangerouslySetInnerHTML in React",
      "description": "dangerouslySetInnerHTML used with user-controlled data. React does not escape; raw HTML is rendered, enabling XSS.",
      "severity": "critical",
      "pattern": "dangerouslySetInnerHTML\\s*=\\s*\\{\\s*__html\\s*:\\s*[^}]+\\}",
      "fix_template": "Use children for text content. If HTML is required, sanitize with DOMPurify: dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userContent) }}.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-79",
      "owasp_category": "A03:2021 - Injection",
      "category": "xss",
      "message": "User input is passed to dangerouslySetInnerHTML. Attackers can inject scripts to steal session tokens or deface the page.",
      "technical_detail": "dangerouslySetInnerHTML bypasses React's default escaping. Any user-controlled value must be sanitized with DOMPurify or similar before use.",
      "ai_risk_explanation": "AI suggests dangerouslySetInnerHTML when asked to render 'HTML from an API' or 'rich content' without mentioning sanitization.",
      "vulnerable_example": "dangerouslySetInnerHTML={{ __html: userInput }}",
      "multiline": false
    },
    {
      "id": "xss-document-write",
      "name": "XSS - document.write",
      "description": "document.write used with user input. Writes raw HTML/JS to the document; enables script injection.",
      "severity": "critical",
      "pattern": "document\\.write\\s*\\([^)]*(?:\\+|\\$\\{|req\\.|params\\.|query\\.|userInput|innerHTML)",
      "fix_template": "Use DOM APIs (createElement, textContent, appendChild) or innerHTML with sanitized content. Avoid document.write with any dynamic data.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-79",
      "owasp_category": "A03:2021 - Injection",
      "category": "xss",
      "message": "document.write is used with user or dynamic data. Attackers can inject scripts that execute in the page context.",
      "technical_detail": "document.write inserts raw HTML. Combined with user input, it enables XSS. Prefer DOM manipulation or sanitized innerHTML.",
      "ai_risk_explanation": "AI uses document.write in legacy-style examples for dynamic content.",
      "vulnerable_example": "document.write(userInput)",
      "multiline": false
    },
    {
      "id": "xss-unsafe-jquery",
      "name": "XSS - Unsafe jQuery",
      "description": "jQuery .html(), .append(), or similar used with user input. Injects unescaped HTML and enables XSS.",
      "severity": "critical",
      "pattern": "\\$\\([^)]+\\)\\.(html|append|prepend|before|after|replaceWith)\\s*\\([^)]*(?:\\+|\\$\\{|params\\.|query\\.|userInput)",
      "fix_template": "Use .text() for plain text, or .html(DOMPurify.sanitize(userInput)). Never pass unsanitized user input to .html(), .append(), etc.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-79",
      "owasp_category": "A03:2021 - Injection",
      "category": "xss",
      "message": "jQuery .html() or .append() receives user input. Unescaped HTML allows script injection and XSS.",
      "technical_detail": ".html() and .append() parse HTML. User input with <script> or event handlers executes. Use .text() or sanitize before .html().",
      "ai_risk_explanation": "AI uses .html() and .append() as the quick way to inject dynamic content in jQuery-based code.",
      "vulnerable_example": "$(selector).html(userInput) or .append(userInput)",
      "multiline": false
    },
    {
      "id": "xss-unescaped-template-variables",
      "name": "XSS - Unescaped Template Variables",
      "description": "Triple-brace or similar syntax in Handlebars, Mustache, or other templates disables escaping. User input rendered as raw HTML.",
      "severity": "critical",
      "pattern": "\\{\\{\\{[^}]+\\}\\}\\}|\\{\\{[^#/^>][^}]*\\|\\s*raw\\s*\\}\\}|<%-\\s*[^%]+%>|\\{\\{\\s*\\|[^}]*raw",
      "fix_template": "Use double braces {{value}} for escaped output. Use triple braces only when content is from trusted source and already sanitized.",
      "languages": ["javascript", "typescript"],
      "cwe": "CWE-79",
      "owasp_category": "A03:2021 - Injection",
      "category": "xss",
      "message": "Template uses unescaped output (triple braces, | raw). User input is rendered as HTML, enabling XSS.",
      "technical_detail": "{{{var}}} in Handlebars and {{var|raw}} in some engines output raw HTML. Use {{var}} for auto-escaping. Triple-brace only for pre-sanitized trusted content.",
      "ai_risk_explanation": "AI uses triple-brace or raw filters when tutorials show 'rendering HTML' without explaining the XSS risk.",
      "vulnerable_example": "{{{userInput}}} or {{userInput|raw}}",
      "multiline": false
    }
  ]
}
