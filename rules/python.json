{
  "rules": [
    {
      "id": "sql-injection-string-formatting",
      "name": "SQL Injection - String Formatting",
      "description": "SQL query built with % formatting, f-strings, .format(), or string concatenation. User input is embedded as raw text and can alter query structure.",
      "severity": "critical",
      "pattern": "(?:(?:cursor\\.execute|execute|\\\\.raw)\\s*\\([^)]*(?:%(?!s\\b)\\s*\\w+|f[\"'].*SELECT|\\\\.format\\s*\\(|[\"'`]\\s*\\+\\s*\\w+))|f[\"'\"][^\"'']*(?:SELECT|INSERT|UPDATE|DELETE|FROM)[^\"'']*[\"'\"](?=\\s*(?:;|$|\\+|\\.execute|\\.query))",
      "fix_template": "Use parameterized queries: cursor.execute('SELECT * FROM users WHERE id = %s', (user_id,))",
      "languages": ["python"],
      "cwe": "CWE-89",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "Database queries are built by embedding user input with % formatting, f-strings, or .format(). An attacker could inject SQL to steal data, modify records, or take over the database.",
      "technical_detail": "String formatting (% s, f-strings, .format()) interpolates user input as part of the SQL string. The database interprets it as code. Use parameterized queries with placeholders (%s, ?) and pass values as a separate tuple/list so the driver treats input as data.",
      "ai_risk_explanation": "AI uses f-strings and .format() for simplicity without understanding that SQL requires parameterization, not string interpolation.",
      "vulnerable_example": "cursor.execute(\"SELECT * FROM users WHERE id = %s\" % user_id) or cursor.execute(f\"SELECT * FROM users WHERE name = '{username}'\")",
      "multiline": false
    },
    {
      "id": "sql-injection-format-method",
      "name": "SQL Injection - Format Method",
      "description": "SQL query built with str.format() or similar. User-controlled values in format placeholders allow SQL injection.",
      "severity": "critical",
      "pattern": "(?:execute|query|raw)\\s*\\([^)]*[\"'].*\\{\\}.*[\"']\\.format\\s*\\(",
      "fix_template": "Use parameterized queries: cursor.execute('SELECT * FROM users WHERE name = %s', (username,))",
      "languages": ["python"],
      "cwe": "CWE-89",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "SQL is built with .format() so user input becomes part of the query string. Attackers can inject SQL syntax to read or modify data.",
      "technical_detail": "str.format() substitutes values into the query string before it reaches the DB driver. Use the driver's parameter binding (e.g. %s with a tuple) so values are sent as parameters, not concatenated SQL.",
      "ai_risk_explanation": "AI prefers .format() for readability and does not distinguish between safe string formatting and unsafe SQL construction.",
      "vulnerable_example": "\"SELECT * FROM users WHERE name = '{}'\".format(username)",
      "multiline": false
    },
    {
      "id": "command-injection-os-system",
      "name": "Command Injection - os.system",
      "description": "os.system() called with concatenated or interpolated user input. Spawns a shell; input can run arbitrary commands.",
      "severity": "critical",
      "pattern": "os\\.system\\s*\\([^)]*(?:[\"'`][^\"'`]*[\"'`]\\s*\\+|f[\"'`][^\"'`]*[\"'`]|%\\s*\\w+)",
      "fix_template": "Use subprocess.run([cmd, arg1, arg2], shell=False) with a list of arguments. Never pass user input into a single command string for os.system.",
      "languages": ["python"],
      "cwe": "CWE-78",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "Shell commands are built from user input via concatenation or f-strings. An attacker can inject commands (e.g., ; rm -rf /) to run arbitrary code on the server.",
      "technical_detail": "os.system() runs its argument in the system shell. Any user input in the string can include shell metacharacters. Use subprocess with shell=False and a list of arguments so input is not interpreted as shell syntax.",
      "ai_risk_explanation": "AI chooses os.system as 'simpler' than subprocess and does not account for injection when variables are embedded in the command string.",
      "vulnerable_example": "os.system(\"ls \" + user_input) or os.system(f\"git clone {url}\")",
      "multiline": false
    },
    {
      "id": "command-injection-subprocess-shell",
      "name": "Command Injection - subprocess with shell=True",
      "description": "subprocess.run/call/Popen with shell=True and user-controlled command string. Same injection risk as os.system.",
      "severity": "critical",
      "pattern": "subprocess\\.(run|call|Popen)\\s*\\([^)]*shell\\s*=\\s*True",
      "fix_template": "Use shell=False and pass executable and arguments as a list: subprocess.run([executable, arg1, arg2])",
      "languages": ["python"],
      "cwe": "CWE-78",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "subprocess is invoked with shell=True. If the command or arguments include user input, attackers can inject shell metacharacters to run arbitrary commands.",
      "technical_detail": "shell=True runs the command through the shell. User input in the command string is interpreted as shell syntax. Use shell=False and pass a list [executable, arg1, arg2] so arguments are not parsed by the shell.",
      "ai_risk_explanation": "AI suggests shell=True to make subprocess 'easier' (e.g. for pipes or wildcards) without considering that it enables command injection when input is dynamic.",
      "vulnerable_example": "subprocess.run(user_command, shell=True)",
      "multiline": false
    },
    {
      "id": "template-injection-jinja2",
      "name": "Template Injection - Jinja2",
      "description": "Jinja2 Template() or render with user input as template source. Enables server-side template injection and possible RCE.",
      "severity": "critical",
      "pattern": "(?:Template|Environment)\\([^)]*(?:request\\.|req\\.|user_input|params|form|args)|\\u005c.render\\s*\\([^)]*request\\.|\\u005c.from_string\\s*\\([^)]*request\\.",
      "fix_template": "Never render user input as template source. Use templates with fixed structure and pass only data (e.g. Template(template_string).render(data=user_data)).",
      "languages": ["python"],
      "cwe": "CWE-94",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User input is passed into Jinja2 as template content or used in f-strings inside templates. Attackers can inject template syntax to execute Python code on the server.",
      "technical_detail": "Jinja2 can execute expressions and limited code. If user input is the template string or embedded unsafely, attackers use {{ config.items() }} or {{ ''.__class__.__mro__[1].__subclasses__() }} for RCE. Use fixed templates and pass data only.",
      "ai_risk_explanation": "AI uses Template(user_input).render() or f-strings in templates for dynamic content without distinguishing template structure from user-controlled template code.",
      "vulnerable_example": "Template(user_input).render() or render_template_string(request.form['template'])",
      "multiline": false
    },
    {
      "id": "ldap-injection",
      "name": "LDAP Injection",
      "description": "LDAP filter or DN built with string concatenation or formatting. User input can alter filter logic or inject LDAP syntax.",
      "severity": "critical",
      "pattern": "(?:search|search_s|filter)\\s*[=(:].*[\"'`].*[\"'`]\\s*\\+|\\.format\\s*\\([^)]*\\).*ldap|f[\"'`].*ldap|%\\s*.*ldap",
      "fix_template": "Escape LDAP special characters (* ( ) \\ \\0) in user input, or use parameterized/bind APIs. Never concatenate user input into LDAP filters.",
      "languages": ["python"],
      "cwe": "CWE-90",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "LDAP search filters or DNs are built from user input. Attackers can inject filter syntax to bypass authentication or dump directory data.",
      "technical_detail": "LDAP filters use special characters. Concatenating user input allows injection (e.g. )(uid=*)) to match all. Escape input or use safe bind/parameter APIs.",
      "ai_risk_explanation": "AI treats LDAP like SQL and uses simple string concatenation or .format() for filter construction.",
      "vulnerable_example": "conn.search_s(base_dn, ldap.SCOPE_SUBTREE, '(uid=' + username + ')')",
      "multiline": false
    },
    {
      "id": "xpath-injection",
      "name": "XPath Injection",
      "description": "XPath query built with string concatenation or formatting. User input can modify XPath logic and read or manipulate XML.",
      "severity": "critical",
      "pattern": "(?:xpath|evaluate|find|findall)\\s*\\([^)]*[\"'`][^\"'`]*(?:\\+[^)]+|\\.format\\s*\\(|f[\"'`])",
      "fix_template": "Use parameterized XPath where supported, or validate/sanitize input. Avoid building XPath from user strings.",
      "languages": ["python"],
      "cwe": "CWE-643",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "XPath queries include user input via concatenation or formatting. Attackers can inject XPath to read or manipulate XML data.",
      "technical_detail": "XPath injection occurs when user input is concatenated into XPath strings. Escape special characters or use parameterized XPath APIs if available.",
      "ai_risk_explanation": "AI builds dynamic XPath with string concatenation or f-strings when asked to query XML by user-supplied value.",
      "vulnerable_example": "tree.xpath('//user[name=\"' + user_input + '\"]')",
      "multiline": false
    },
    {
      "id": "path-traversal-open",
      "name": "Path Traversal",
      "description": "open() or os.path.join() with user input without validation. Enables read/write of arbitrary files (e.g. ../../../etc/passwd).",
      "severity": "critical",
      "pattern": "open\\s*\\([^)]*(?:request\\.(args|form|values)|user_input|input\\s*\\(|argv)|os\\.path\\.join\\s*\\([^)]*,\\s*(?:request\\.|user_input|argv)",
      "fix_template": "Validate file paths: resolve with os.path.abspath and ensure result is under an allowed base. Reject paths containing .. or absolute paths from user input.",
      "languages": ["python"],
      "cwe": "CWE-22",
      "owasp_category": "A03:2021 - Injection",
      "category": "path_traversal",
      "message": "File operations use paths taken from user input. Attackers can use .. to escape the intended directory and access sensitive files.",
      "technical_detail": "Path traversal occurs when user input is used in open(), os.path.join(), or similar. Resolve paths and verify they remain under a whitelisted base directory. Reject .. and absolute paths.",
      "ai_risk_explanation": "AI generates straightforward file access from request parameters or input() without considering path traversal.",
      "vulnerable_example": "open(request.args.get('file')) or os.path.join(base, user_input)",
      "multiline": false
    },
    {
      "id": "path-traversal-flask-send-file",
      "name": "Path Traversal - Flask send_file",
      "description": "Flask send_file() with path from request without validation. Can expose arbitrary files on the server.",
      "severity": "critical",
      "pattern": "send_file\\s*\\([^)]*request\\.(args|form|values)\\s*\\.get\\s*\\(|send_file\\s*\\([^)]*request\\.(args|form|values)\\[",
      "fix_template": "Validate path: resolve to real path, ensure it is under an allowed directory, and pass the validated path to send_file. Never use raw request parameters as file path.",
      "languages": ["python"],
      "cwe": "CWE-22",
      "owasp_category": "A03:2021 - Injection",
      "category": "path_traversal",
      "message": "send_file() is called with a path from the request. Attackers can request ../../../etc/passwd or other sensitive files.",
      "technical_detail": "Flask send_file(path) sends the file at path. If path comes from request.args.get('file'), an attacker controls it. Validate and restrict to a known base directory.",
      "ai_risk_explanation": "AI suggests send_file(request.args.get('file')) for download features without adding path validation.",
      "vulnerable_example": "send_file(request.args.get('file'))",
      "multiline": false
    },
    {
      "id": "xml-injection",
      "name": "XML Injection",
      "description": "XML document or query built with string concatenation or formatting from user input. Enables XML injection or XXE.",
      "severity": "critical",
      "pattern": "(?:ElementTree\\.fromstring|parse|etree\\.XML)\\s*\\([^)]*(?:\\+\\s*\\w+|\\.format\\s*\\(|f[\"'`])|xml\\.(?:sax|dom).*\\+\\s*\\w+",
      "fix_template": "Build XML using proper APIs (ElementTree, createElement) with escaped or validated text. Avoid concatenating user input into XML strings. Disable external entities for parsers.",
      "languages": ["python"],
      "cwe": "CWE-91",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "XML is built from user input via concatenation or formatting. Attackers can inject elements, entities, or trigger XXE to read local files.",
      "technical_detail": "String-built XML allows injection of tags or entity references. Use XML APIs to create nodes and set text; escape user data. For parsing, disable external entities (resolve_entities=False, etc.).",
      "ai_risk_explanation": "AI builds XML with f-strings or .format() when asked to create XML from user data.",
      "vulnerable_example": "ElementTree.fromstring('<user><name>' + user_input + '</name></user>')",
      "multiline": false
    },
    {
      "id": "unsafe-pickle-loads",
      "name": "Unsafe pickle.loads",
      "description": "pickle.loads() or pickle.load() with user-controlled data. Deserialization can execute arbitrary Python code (RCE).",
      "severity": "critical",
      "pattern": "pickle\\.(loads?)\\s*\\([^)]*\\)",
      "fix_template": "Do not unpickle untrusted data. Use JSON, msgpack, or other safe formats for data from users or untrusted sources. If pickle is required, verify integrity (e.g. HMAC) and consider restricted unpicklers.",
      "languages": ["python"],
      "cwe": "CWE-502",
      "owasp_category": "A08:2021 - Software and Data Integrity Failures",
      "category": "deserialization",
      "message": "User or untrusted input is deserialized with pickle. Attackers can supply crafted payloads that execute arbitrary code when unpickled.",
      "technical_detail": "Pickle deserialization runs constructor and reduce logic. Malicious pickle payloads can run shell commands or import arbitrary modules. Never unpickle data from untrusted sources.",
      "ai_risk_explanation": "AI uses pickle for serialization because it is built-in and convenient, without understanding RCE risks of deserializing untrusted data.",
      "vulnerable_example": "pickle.loads(user_data) or pickle.load(untrusted_file)",
      "multiline": false
    },
    {
      "id": "unsafe-yaml-load",
      "name": "Unsafe yaml.load",
      "description": "yaml.load() or yaml.load_all() used instead of yaml.safe_load(). Can instantiate arbitrary Python objects and lead to RCE.",
      "severity": "critical",
      "pattern": "yaml\\.load\\s*\\(|yaml\\.load_all\\s*\\(",
      "fix_template": "Use yaml.safe_load() or yaml.safe_load_all() so only basic types are allowed. Never use yaml.load() on untrusted input.",
      "languages": ["python"],
      "cwe": "CWE-502",
      "owasp_category": "A08:2021 - Software and Data Integrity Failures",
      "category": "deserialization",
      "message": "yaml.load() is used on file or user input. Attackers can provide YAML that instantiates dangerous classes (e.g. os.system) and executes code.",
      "technical_detail": "yaml.load() allows arbitrary Python type construction via !!python/object. yaml.safe_load() restricts to safe types (dict, list, str, number, etc.). Always use safe_load for untrusted input.",
      "ai_risk_explanation": "AI uses yaml.load because it appears in older examples and documentation; safe_load is often not the default in snippets.",
      "vulnerable_example": "yaml.load(file) or yaml.load(request.data)",
      "multiline": false
    },
    {
      "id": "eval-user-input",
      "name": "eval() with User Input",
      "description": "eval() called with user or request input. Executes arbitrary Python code with application privileges.",
      "severity": "critical",
      "pattern": "eval\\s*\\([^)]*(?:request\\.|input\\s*\\(|user_|form|args|params)",
      "fix_template": "Remove eval() on user input. Use ast.literal_eval() for literals, or a safe expression evaluator. Never execute user-supplied code.",
      "languages": ["python"],
      "cwe": "CWE-95",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User input is executed as Python via eval(). Attackers can run any code on the server (e.g. os.system, file access).",
      "technical_detail": "eval() interprets a string as Python code. Any user input passed to eval() grants full code execution. Use ast.literal_eval() for safe parsing of literals only, or avoid dynamic evaluation.",
      "ai_risk_explanation": "AI suggests eval() for 'dynamic' Python execution or expression evaluation without security consideration.",
      "vulnerable_example": "eval(user_input) or eval(request.form['code'])",
      "multiline": false
    },
    {
      "id": "exec-user-input",
      "name": "exec() with User Input",
      "description": "exec() called with user or request input. Executes arbitrary Python code (RCE).",
      "severity": "critical",
      "pattern": "exec\\s*\\([^)]*(?:request\\.|input\\s*\\(|user_|form|args|params)",
      "fix_template": "Do not exec() user input. If dynamic code is required, use a sandbox or restricted DSL, not full Python from users.",
      "languages": ["python"],
      "cwe": "CWE-95",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User input is executed as Python via exec(). Attackers can run any code on the server.",
      "technical_detail": "exec() runs the string as Python code. User-controlled input means arbitrary code execution. There is no safe way to exec() untrusted input; use alternatives (templating, sandboxed evaluators).",
      "ai_risk_explanation": "AI proposes exec() for 'run user code' or plugin-style features without considering RCE.",
      "vulnerable_example": "exec(user_code) or exec(request.form.get('script'))",
      "multiline": false
    },
    {
      "id": "compile-user-input",
      "name": "compile() with User Input",
      "description": "compile() called with user input. Compiled code can later be executed and lead to RCE.",
      "severity": "critical",
      "pattern": "compile\\s*\\([^)]*(?:request\\.|input\\s*\\(|user_|form|args|params)",
      "fix_template": "Do not compile() user input. Avoid compiling and executing user-supplied source code.",
      "languages": ["python"],
      "cwe": "CWE-95",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User input is passed to compile(). The resulting code object can be executed (exec/eval) and leads to arbitrary code execution.",
      "technical_detail": "compile(source, ..., 'exec'/'eval') turns a string into a code object. If source is user input, execution of that object is RCE. Do not compile untrusted strings.",
      "ai_risk_explanation": "AI may use compile() for 'optimization' or staged execution without treating it as equivalent to exec on user input.",
      "vulnerable_example": "compile(user_input, '<string>', 'exec')",
      "multiline": false
    },
    {
      "id": "import-user-input",
      "name": "__import__ with User Input",
      "description": "__import__() called with user or request input. Can load arbitrary modules and lead to code execution.",
      "severity": "critical",
      "pattern": "__import__\\s*\\([^)]*(?:request\\.|input\\s*\\(|user_|form|args|params)",
      "fix_template": "Do not __import__() user input. Use a whitelist of allowed module names if dynamic import is required.",
      "languages": ["python"],
      "cwe": "CWE-94",
      "owasp_category": "A03:2021 - Injection",
      "category": "injection",
      "message": "User input is passed to __import__(). Attackers can import os or other modules and use them to run commands or access files.",
      "technical_detail": "__import__(name) loads a module by name. User-controlled name can be 'os' or 'subprocess'; subsequent use of the module enables RCE. Whitelist allowed module names or avoid dynamic import from user input.",
      "ai_risk_explanation": "AI suggests __import__(user_module) for plugin or dynamic loading without restricting the module name.",
      "vulnerable_example": "__import__(request.args.get('module'))",
      "multiline": false
    },
    {
      "id": "missing-login-required",
      "name": "Missing @login_required Decorator",
      "description": "Flask or Django view that appears to handle sensitive data or actions without authentication decorator.",
      "severity": "critical",
      "pattern": "@(?:app\\.route|route)\\s*\\([^)]*\\)\\s*\\n\\s*def\\s+\\w+\\s*\\(|def\\s+(?:get|post|put|delete)\\s*\\([^)]*request\\s*\\)\\s*:",
      "fix_template": "Add @login_required (Flask-Login) or @login_required (Django) to protected views. Ensure authentication is checked before handling sensitive logic.",
      "languages": ["python"],
      "cwe": "CWE-306",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "authentication",
      "message": "Sensitive routes or views are defined without an authentication decorator. Unauthenticated users can access protected endpoints or pages.",
      "technical_detail": "Flask @app.route and Django view functions must be protected with @login_required or equivalent so only authenticated users can access them. Without it, any client can call these handlers.",
      "ai_risk_explanation": "AI generates functional endpoints but omits auth decorators, focusing on request handling rather than access control.",
      "vulnerable_example": "@app.route('/api/users') def list_users(): ...",
      "multiline": true
    },
    {
      "id": "missing-permission-checks",
      "name": "Missing Permission Checks",
      "description": "Django view or Flask route without permission_required or role check. Authenticated users may access beyond their authorization.",
      "severity": "high",
      "pattern": "@(?:login_required)\\s*\\n\\s*@(?:app\\.route|route).*\\n.*def\\s+\\w+.*(?:admin|delete|update|create)|permission_required\\s*=\\s*\\[?\\s*\\]",
      "fix_template": "Add @permission_required('app.permission') (Django) or a custom decorator that checks roles/permissions before sensitive operations.",
      "languages": ["python"],
      "cwe": "CWE-862",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authorization",
      "message": "Views or routes are authenticated but do not check permissions. Any logged-in user may perform admin or privileged actions.",
      "technical_detail": "Authorization requires both authentication and permission checks. Use Django permission_required or Flask decorators that verify user role/permission before executing sensitive logic.",
      "ai_risk_explanation": "AI adds login_required but skips permission or role checks, treating 'logged in' as sufficient for all actions.",
      "vulnerable_example": "@login_required\ndef admin_view(request): ...",
      "multiline": true
    },
    {
      "id": "weak-password-hashing-md5",
      "name": "Weak Password Hashing - MD5",
      "description": "Passwords hashed with hashlib.md5(). MD5 is cryptographically broken and unsuitable for password storage.",
      "severity": "critical",
      "pattern": "hashlib\\.md5\\s*\\([^)]*(?:password|passwd|pwd|secret)\\.encode|hashlib\\.md5\\s*\\([^)]*\\.encode\\s*\\(",
      "fix_template": "Use a dedicated password hasher: bcrypt, argon2, or Django's make_password() / PBKDF2. Never use MD5 or raw SHA for passwords.",
      "languages": ["python"],
      "cwe": "CWE-327",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "Passwords are hashed with MD5. MD5 is fast and broken; attackers can crack or rainbow-table hashes. Use a proper password hashing algorithm.",
      "technical_detail": "MD5 is not collision-resistant and is too fast for password hashing. Use bcrypt, scrypt, or Argon2 (or Django's make_password) which include salt and cost factors.",
      "ai_risk_explanation": "AI uses MD5 from generic hashing examples without understanding it is cryptographically weak and inappropriate for passwords.",
      "vulnerable_example": "hashlib.md5(password.encode()).hexdigest()",
      "multiline": false
    },
    {
      "id": "weak-password-hashing-sha-no-salt",
      "name": "Weak Password Hashing - SHA without Salt",
      "description": "Passwords hashed with SHA1/SHA256/SHA512 without salt or iterations. Vulnerable to rainbow tables and brute force.",
      "severity": "critical",
      "pattern": "hashlib\\.(sha1|sha256|sha512)\\s*\\([^)]*(?:password|passwd|pwd)\\.encode|hashlib\\.(sha1|sha256|sha512)\\s*\\([^)]*\\.encode\\s*\\(",
      "fix_template": "Use bcrypt, argon2, or PBKDF2 with salt and high iteration count. Do not use raw SHA for password storage.",
      "languages": ["python"],
      "cwe": "CWE-759",
      "owasp_category": "A02:2021 - Cryptographic Failures",
      "category": "cryptography",
      "message": "Passwords are hashed with SHA without salt or key derivation. Attackers can use rainbow tables or fast brute force. Use a proper password hashing scheme.",
      "technical_detail": "SHA alone is deterministic and fast. Passwords need a unique salt and a slow KDF (PBKDF2, bcrypt, Argon2) to resist cracking. Use hashlib.pbkdf2_hmac with salt and high iterations, or a dedicated library.",
      "ai_risk_explanation": "AI uses SHA256 from 'hashing' examples without adding salt or iterations, leading to weak password storage.",
      "vulnerable_example": "hashlib.sha256(password.encode()).hexdigest()",
      "multiline": false
    },
    {
      "id": "django-default-secret-key",
      "name": "Default Django SECRET_KEY",
      "description": "Django SECRET_KEY set to default, placeholder, or hardcoded value. Compromises session signing and CSRF protection.",
      "severity": "critical",
      "pattern": "SECRET_KEY\\s*=\\s*['\"](?:django-insecure|dev|change-me|secret|placeholder|your-secret)[^'\"]*['\"]|SECRET_KEY\\s*=\\s*['\"][a-zA-Z0-9]{20,}['\"]",
      "fix_template": "Use a random SECRET_KEY from environment (e.g. os.environ.get('SECRET_KEY')). Generate with secrets.token_hex(50). Never commit production keys.",
      "languages": ["python"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "SECRET_KEY is default or hardcoded. Attackers can forge sessions, CSRF tokens, and signed data if the key is known or guessable.",
      "technical_detail": "Django uses SECRET_KEY for signing sessions, CSRF tokens, and password reset tokens. A fixed or default key allows forgery. Load from environment and use a long random value in production.",
      "ai_risk_explanation": "AI leaves SECRET_KEY as in Django startproject or uses a simple placeholder without emphasizing that it must be secret and unique per deployment.",
      "vulnerable_example": "SECRET_KEY = 'django-insecure-xxx' or SECRET_KEY = 'dev'",
      "multiline": false
    },
    {
      "id": "flask-secret-key-hardcoded",
      "name": "Flask Secret Key from String",
      "description": "Flask app.secret_key set to a hardcoded or weak value. Compromises session cookie signing.",
      "severity": "critical",
      "pattern": "(?:app\\.secret_key|SECRET_KEY)\\s*=\\s*['\"][^'\"]{0,50}['\"]",
      "fix_template": "Use app.secret_key = os.environ.get('SECRET_KEY') with a long random value in production. Generate with secrets.token_hex(32).",
      "languages": ["python"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "Flask secret_key is hardcoded (e.g. 'dev'). Attackers can forge or tamper with session cookies if the key is known.",
      "technical_detail": "Flask uses secret_key to sign session cookies. A weak or default key allows session forgery. Load from environment and use a cryptographically random value.",
      "ai_risk_explanation": "AI sets app.secret_key = 'dev' or similar for quick examples without warning that production must use a secret from environment.",
      "vulnerable_example": "app.secret_key = 'dev' or app.secret_key = 'my-secret'",
      "multiline": false
    },
    {
      "id": "hardcoded-api-keys",
      "name": "Hardcoded API Keys/Passwords",
      "description": "API key, password, or token stored as a string literal in source code. Leaked via repo or binary.",
      "severity": "critical",
      "pattern": "(?:API_KEY|api_key|SECRET|password|PASSWORD|token|TOKEN|auth_key)\\s*=\\s*['\"][^'\"]+['\"]",
      "fix_template": "Load from environment: os.environ.get('API_KEY') or a secrets manager. Never commit keys to source control.",
      "languages": ["python"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "secrets",
      "message": "API keys or passwords are hardcoded in the codebase. They can be exposed via version control, logs, or deployment artifacts.",
      "technical_detail": "Secrets in source code are committed to Git and may be exposed. Use environment variables, .env (not committed), or a secrets manager. Validate that required env vars are set at startup.",
      "ai_risk_explanation": "AI inserts literal API_KEY = '...' from examples to make code runnable without mentioning that real keys must come from environment or config.",
      "vulnerable_example": "API_KEY = 'sk-...' or password = 'admin123'",
      "multiline": false
    },
    {
      "id": "jwt-without-expiration",
      "name": "JWT Without Expiration",
      "description": "JWT created with PyJWT/jwt.encode without exp (expiration) claim. Tokens never expire and can be reused if leaked.",
      "severity": "high",
      "pattern": "jwt\\.encode\\s*\\([^)]*payload[^)]*,\\s*[^)]*key|encode\\s*\\([^)]*payload[^)]*,\\s*[^)]*algorithm",
      "fix_template": "Include exp in payload: payload = {..., 'exp': datetime.utcnow() + timedelta(hours=1)} or use PyJWT's exp in payload and verify with decode(..., options={'verify_exp': True}).",
      "languages": ["python"],
      "cwe": "CWE-613",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "authentication",
      "message": "JWT is encoded without an expiration claim. Stolen tokens remain valid indefinitely.",
      "technical_detail": "JWTs should include 'exp' (expiration time) and optionally 'iat'. Verify exp on decode. Without exp, tokens cannot be invalidated except by changing the secret.",
      "ai_risk_explanation": "AI generates jwt.encode(payload, key) without adding exp, focusing on signing rather than token lifecycle.",
      "vulnerable_example": "jwt.encode(payload, key) without exp in payload",
      "multiline": false
    },
    {
      "id": "django-debug-true",
      "name": "Django DEBUG = True",
      "description": "DEBUG = True in Django settings. Exposes stack traces and sensitive data in production.",
      "severity": "high",
      "pattern": "DEBUG\\s*=\\s*True",
      "fix_template": "Set DEBUG = False in production. Use environment variable: DEBUG = os.environ.get('DJANGO_DEBUG', 'False') == 'True'.",
      "languages": ["python"],
      "cwe": "CWE-489",
      "owasp_category": "A05:2021 - Security Misconfiguration",
      "category": "configuration",
      "message": "DEBUG is enabled. In production this exposes detailed error pages and environment information to users.",
      "technical_detail": "DEBUG = True shows full stack traces, settings, and SQL. Never enable in production. Use ALLOWED_HOSTs and separate settings for prod; enable DEBUG only in dev.",
      "ai_risk_explanation": "AI leaves DEBUG on because tutorials and examples show it enabled for convenience.",
      "vulnerable_example": "DEBUG = True",
      "multiline": false
    },
    {
      "id": "flask-debug-true",
      "name": "Flask debug = True",
      "description": "app.run(debug=True) in production code. Enables debugger and reloader; can expose code execution.",
      "severity": "high",
      "pattern": "app\\.run\\s*\\([^)]*debug\\s*=\\s*True|\\.run\\s*\\([^)]*debug\\s*=\\s*True",
      "fix_template": "Use app.run(debug=False) in production, or run via gunicorn/uWSGI without debug. Do not use debug mode in production.",
      "languages": ["python"],
      "cwe": "CWE-489",
      "owasp_category": "A05:2021 - Security Misconfiguration",
      "category": "configuration",
      "message": "Flask is run with debug=True. This enables the Werkzeug debugger, which can allow remote code execution if exposed.",
      "technical_detail": "debug=True runs the built-in debugger and reloader. The debugger console is dangerous if reachable. Production should use a production WSGI server with debug off.",
      "ai_risk_explanation": "AI uses app.run(debug=True) in examples so that code changes reload; this is not safe for production.",
      "vulnerable_example": "app.run(debug=True)",
      "multiline": false
    },
    {
      "id": "cors-allow-all-origins",
      "name": "CORS Allow All Origins",
      "description": "CORS configured to allow all origins (*). Any site can make authenticated cross-origin requests.",
      "severity": "high",
      "pattern": "CORS\\s*\\([^)]*origins\\s*=\\s*['\"]\\*['\"]|allow_origins\\s*=\\s*['\"]\\*['\"]|Access-Control-Allow-Origin\\s*['\"]\\*['\"]|resources\\s*=\\s*\\{[^}]*origins\\s*:\\s*['\"]\\*['\"]",
      "fix_template": "Restrict origins to known frontend domains: CORS(app, origins=['https://myapp.com']) or allow_origins=['https://myapp.com'].",
      "languages": ["python"],
      "cwe": "CWE-942",
      "owasp_category": "A05:2021 - Security Misconfiguration",
      "category": "configuration",
      "message": "CORS allows any origin. Malicious sites can send requests with user credentials and read responses, enabling CSRF and data theft.",
      "technical_detail": "origins='*' or allow_origins=['*'] allows any website to make cross-origin requests. Restrict to specific trusted origins. Do not use * with credentials.",
      "ai_risk_explanation": "AI sets CORS(app, origins=['*']) to avoid frontend CORS errors without locking down origins for production.",
      "vulnerable_example": "CORS(app, origins=['*']) or allow_origins=['*']",
      "multiline": false
    },
    {
      "id": "disabled-ssl-verification",
      "name": "Disabled SSL Verification",
      "description": "requests.get/post or similar called with verify=False. Disables certificate verification and enables MITM attacks.",
      "severity": "high",
      "pattern": "(?:requests\\.(get|post|put|patch|delete)|urllib3)\\.?.*\\.(request|urlopen)\\s*\\([^)]*verify\\s*=\\s*False|verify\\s*=\\s*False",
      "fix_template": "Use verify=True (default). Fix certificate issues by using correct CA bundle or installing certs; do not disable verification in production.",
      "languages": ["python"],
      "cwe": "CWE-295",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "configuration",
      "message": "SSL/TLS verification is disabled. Connections are vulnerable to man-in-the-middle attacks and credential theft.",
      "technical_detail": "verify=False disables server certificate validation. All HTTPS traffic can be intercepted if an attacker is on the path. Always use verify=True; fix cert issues properly.",
      "ai_risk_explanation": "AI disables SSL verification to 'fix' certificate errors in examples instead of guiding users to correct CA or certificate configuration.",
      "vulnerable_example": "requests.get(url, verify=False)",
      "multiline": false
    },
    {
      "id": "verbose-error-responses",
      "name": "Verbose Error Responses",
      "description": "Exception message or stack trace returned to client in HTTP response. Leaks internal paths and logic.",
      "severity": "high",
      "pattern": "return\\s+(?:str\\s*\\(\\s*e\\s*\\)|str\\s*\\(\\s*exception\\s*\\)|traceback\\.format_exc|repr\\s*\\(\\s*e\\s*\\))|(?:json\\.)?(?:dump|dumps)\\s*\\([^)]*exception|Response\\s*\\([^)]*str\\s*\\(\\s*e\\s*\\)",
      "fix_template": "Log the exception server-side. Return a generic error message to the client (e.g. 'An error occurred'). Do not expose tracebacks or exception details in production.",
      "languages": ["python"],
      "cwe": "CWE-209",
      "owasp_category": "A04:2021 - Insecure Design",
      "category": "error_handling",
      "message": "Error responses include exception text or stack traces. Attackers can learn about paths, libraries, and logic from these messages.",
      "technical_detail": "Returning str(e) or traceback to the client exposes internal details. Log full tracebacks server-side; return a generic user-facing message and optional error ID.",
      "ai_risk_explanation": "AI returns str(exception) or traceback in error handlers to make debugging easier, without considering information disclosure.",
      "vulnerable_example": "return str(exception) or return traceback.format_exc()",
      "multiline": false
    },
    {
      "id": "missing-input-validation",
      "name": "Missing Input Validation",
      "description": "request.form, request.args, or request.json used directly without validation. Enables injection, bad data, and logic abuse.",
      "severity": "high",
      "pattern": "(?:request\\.(form|args|values|json)\\s*\\[|request\\.(form|args|values|get)\\.get\\s*\\([^)]*\\))\\s*(?!.*(?:validate|schema|parse|Marshal|serialize|Regexp|Length|OneOf))",
      "fix_template": "Validate and sanitize input: use Marshmallow, Pydantic, or manual checks (type, length, allowlist). Reject invalid or unexpected values before use.",
      "languages": ["python"],
      "cwe": "CWE-20",
      "owasp_category": "A03:2021 - Injection",
      "category": "validation",
      "message": "User input from request is used without validation. Invalid or malicious input can cause injection, crashes, or unexpected behavior.",
      "technical_detail": "Always validate and sanitize user input: type, range, format, length. Use a schema library (Marshmallow, Pydantic) or explicit checks. Do not trust request.form/args/json in business logic without validation.",
      "ai_risk_explanation": "AI uses request.form.get('field') or request.args['key'] directly to keep code short, skipping validation steps.",
      "vulnerable_example": "username = request.form.get('username') then used in query without validation",
      "multiline": false
    }
  ]
}
