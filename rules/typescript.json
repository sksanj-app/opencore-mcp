{
  "rules": [
    {
      "id": "type-coercion-any-security",
      "name": "Type Coercion Vulnerabilities",
      "description": "Using 'any' type in security-sensitive contexts (e.g. user input, request body) disables type checking and allows arbitrary data to flow into trusted operations.",
      "severity": "high",
      "pattern": "function\\s+\\w+\\s*\\([^)]*:\\s*any\\b|(?:processInput|handleInput|parseBody|validateRequest|req\\.body|userInput)\\s*[,:]\\s*any\\b",
      "fix_template": "Replace 'any' with a concrete type or branded type. For user input use a runtime-validated type (e.g. z.infer<typeof schema>) after Zod/Yup parsing.",
      "languages": ["typescript"],
      "cwe": "CWE-704",
      "owasp_category": "A03:2021 - Injection",
      "category": "data_validation",
      "message": "Security-sensitive parameters are typed as 'any', so TypeScript cannot enforce shape or constrain attacker-controlled data.",
      "technical_detail": "The 'any' type opts out of type checking. For user input, request bodies, or external data, this allows malformed or malicious payloads to reach business logic. Use strict types and runtime validation (Zod, Yup) instead.",
      "ai_risk_explanation": "AI uses 'any' for user input or request data to avoid type errors and reduce boilerplate, without considering that this bypasses type safety in security-sensitive paths.",
      "vulnerable_example": "function processInput(data: any) { return db.query(data.id); }",
      "multiline": false
    },
    {
      "id": "unsafe-type-assertion",
      "name": "Unsafe Type Assertions",
      "description": "Type assertion (e.g. 'user as AdminUser') without runtime validation. Assertions are erased at compile time and provide no runtime guarantee.",
      "severity": "high",
      "pattern": "\\bas\\s+(?:AdminUser|User|AuthenticatedUser|Role|Permissions)\\b|\\s+as\\s+[A-Z][a-zA-Z0-9]*\\s*[;),]",
      "fix_template": "Replace assertions with runtime checks: use type guards (e.g. 'user' in obj && obj.role === 'admin') or validate with Zod/Yup and infer the type from the schema.",
      "languages": ["typescript"],
      "cwe": "CWE-704",
      "owasp_category": "A04:2021 - Insecure Design",
      "category": "data_validation",
      "message": "Code asserts a type (e.g. AdminUser) without verifying it at runtime. An attacker can send unprivileged data that is treated as privileged.",
      "technical_detail": "TypeScript's 'as' and angle-bracket assertions are not emitted to JavaScript. The runtime value is unchanged; only the compiler is told to treat it as that type. Use type guards or schema validation to enforce types at runtime.",
      "ai_risk_explanation": "AI uses type assertions to satisfy the type checker and avoid writing validation logic, assuming that types provide runtime security.",
      "vulnerable_example": "const admin = user as AdminUser; admin.deleteAll();",
      "multiline": false
    },
    {
      "id": "missing-runtime-validation-types-only",
      "name": "Missing Runtime Validation Despite Types",
      "description": "TypeScript interfaces or types used for request/input without runtime validation. Types are erased at compile time; only runtime validation (Zod, Yup) enforces shape.",
      "severity": "high",
      "pattern": "(?:req\\.body|req\\.query|input|params)\\s*:\\s*(?:I[A-Z]\\w+|interface\\s+\\w+|[A-Z][a-zA-Z]+)\\s*[;=]|(?:body|query)\\s*as\\s+[A-Z]\\w+",
      "fix_template": "Add runtime validation: parse req.body/input with Zod (z.object().parse()) or Yup before use. Use z.infer<typeof schema> for the TypeScript type.",
      "languages": ["typescript"],
      "cwe": "CWE-20",
      "owasp_category": "A03:2021 - Injection",
      "category": "data_validation",
      "message": "Input is typed with an interface but never validated at runtime. Attackers can send arbitrary JSON that does not match the interface.",
      "technical_detail": "TypeScript types and interfaces exist only at compile time. At runtime, req.body or input can be any shape. Validate with a schema library (Zod, Yup) and derive types from the schema.",
      "ai_risk_explanation": "AI assumes TypeScript types provide runtime security and omits validation, leading to invalid or malicious data being used as if it matched the type.",
      "vulnerable_example": "const body = req.body as CreateUserRequest; await db.users.create(body);",
      "multiline": false
    },
    {
      "id": "nextjs-getserversideprops-no-auth",
      "name": "NextJS getServerSideProps Without Auth",
      "description": "getServerSideProps fetches sensitive data without verifying authentication or authorization. Unauthenticated users may receive data intended for authenticated ones.",
      "severity": "critical",
      "pattern": "getServerSideProps\\s*(?:async)?\\s*\\([^)]*\\)\\s*(?:=>|\\{)(?:(?!getSession|getServerSession|requireAuth|auth\\s*\\(|session\\s*\\()\\)\\.)*?return\\s*\\{",
      "fix_template": "At the start of getServerSideProps, call getSession/getServerSession (e.g. NextAuth). If no session, return { redirect: { destination: '/login' } }. Never return sensitive props without auth.",
      "languages": ["typescript"],
      "cwe": "CWE-306",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authentication",
      "message": "Server-side props are loaded without checking if the user is authenticated. Sensitive data may be exposed to unauthenticated requests.",
      "technical_detail": "getServerSideProps runs on every request. If it does not call getSession/getServerSession and redirect when unauthenticated, any caller can receive the same props. Always validate session before returning sensitive data.",
      "ai_risk_explanation": "AI generates getServerSideProps to fetch data for the page but often omits auth checks, especially when the prompt does not explicitly ask for authentication.",
      "vulnerable_example": "export async function getServerSideProps() { const data = await fetchSensitiveData(); return { props: { data } }; }",
      "multiline": true
    },
    {
      "id": "nextjs-api-route-no-validation",
      "name": "NextJS API Route Without Validation",
      "description": "API routes in app/api or pages/api that accept request body or query without input validation. Unvalidated input can lead to injection, IDOR, or logic bugs.",
      "severity": "high",
      "pattern": "(?:export\\s+)?(?:async\\s+)?function\\s+(?:GET|POST|PUT|PATCH|DELETE)\\s*\\([^)]*Request[^)]*\\)[^{]*\\{[^}]*(?:req\\.body|req\\.query|request\\.json)\\s*(?![^}]*(?:z\\.parse|yup\\.validate|schema\\.parse|validate\\s*\\())",
      "fix_template": "Validate all input: parse body with Zod (e.g. bodySchema.parse(await req.json())) or Yup. Reject with 400 if validation fails. Do not trust req.body or query without validation.",
      "languages": ["typescript"],
      "cwe": "CWE-20",
      "owasp_category": "A03:2021 - Injection",
      "category": "data_validation",
      "message": "API route uses request data without validation. Malformed or malicious input can reach the database or business logic.",
      "technical_detail": "Next.js API routes receive req.body and req.query as arbitrary data. Without schema validation (Zod, Yup), invalid types, extra fields, or injection payloads can be processed. Always parse and validate before use.",
      "ai_risk_explanation": "AI writes API handlers that use req.body or req.query directly to keep examples short, skipping validation steps.",
      "vulnerable_example": "export async function POST(req: Request) { const { id } = await req.json(); return db.getItem(id); }",
      "multiline": true
    },
    {
      "id": "trpc-procedure-without-auth",
      "name": "tRPC Procedure Without Auth",
      "description": "tRPC mutations or queries that modify or return sensitive data without middleware protection (e.g. auth check). Procedures may be callable by unauthenticated or unauthorized callers.",
      "severity": "high",
      "pattern": "(?:mutation|query)\\s*\\.(?:useMutation|useQuery)|procedure\\s*\\.(?:mutation|query)\\s*\\([^)]*\\)\\s*(?![^}]*(?:protectedProcedure|auth|getServerSession))",
      "fix_template": "Use protectedProcedure (or equivalent) that runs auth middleware. Ensure middleware verifies session and attaches user to context. Do not expose sensitive mutations/queries as publicProcedure.",
      "languages": ["typescript"],
      "cwe": "CWE-306",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authentication",
      "message": "tRPC procedure is callable without authentication. Sensitive operations should be behind protectedProcedure or similar.",
      "technical_detail": "tRPC procedures are public by default. Mutations that change data or queries that return sensitive data must use a procedure that runs auth middleware and rejects unauthenticated callers.",
      "ai_risk_explanation": "AI defines tRPC procedures without attaching auth middleware, especially when the prompt focuses on 'add an endpoint' rather than access control.",
      "vulnerable_example": "deleteUser: publicProcedure.input(z.object({ id: z.string() })).mutation(({ input }) => db.users.delete(input.id))",
      "multiline": false
    },
    {
      "id": "graphql-resolver-no-type-validation",
      "name": "GraphQL Resolver Without Type Validation",
      "description": "GraphQL resolvers accept args without runtime schema validation. GraphQL validates types at the boundary but custom args or context may still need validation.",
      "severity": "medium",
      "pattern": "(?:Query|Mutation|Resolver)\\s*:\\s*\\{[^}]*(?:args|parent|context)[^}]*(?![^}]*z\\.parse|[^}]*yup\\.validate|[^}]*validate\\s*\\()",
      "fix_template": "Validate resolver args with Zod or Yup when args come from untrusted input or when using dynamic/JSON fields. Validate context (e.g. user) when enforcing authorization.",
      "languages": ["typescript"],
      "cwe": "CWE-20",
      "owasp_category": "A03:2021 - Injection",
      "category": "data_validation",
      "message": "Resolver uses args or context without runtime validation. Malformed or forged args can lead to injection or privilege escalation.",
      "technical_detail": "GraphQL schema validates the shape of arguments at the gateway, but custom scalars, dynamic data, or context (e.g. user role) may need explicit validation in the resolver. Validate before using in DB or external calls.",
      "ai_risk_explanation": "AI assumes GraphQL's type system is sufficient at runtime and skips extra validation in resolvers.",
      "vulnerable_example": "Mutation: { createUser: (_, args) => db.users.create(args.input) }",
      "multiline": false
    },
    {
      "id": "missing-zod-yup-schema-validation",
      "name": "Missing Zod/Yup Schema Validation",
      "description": "Endpoints or handlers accepting user input (body, query, params) without schema-based validation. Raw input is used as-is, enabling injection or logic flaws.",
      "severity": "high",
      "pattern": "(?:req\\.body|req\\.query|req\\.params|request\\.body|body|query|params)\\s*(?:\\.[a-zA-Z]+\\s*)?[;,=]|[^(]*(?:body|query|params)\\s*\\}\\s*(?![^}]*\\.parse\\(|[^}]*\\.validate\\(|[^}]*yup)",
      "fix_template": "Define a Zod or Yup schema for the expected input. Parse/validate before any business logic. Return 400 with validation errors on failure.",
      "languages": ["typescript"],
      "cwe": "CWE-20",
      "owasp_category": "A03:2021 - Injection",
      "category": "data_validation",
      "message": "User input is used without schema validation. Invalid or malicious payloads can reach the application.",
      "technical_detail": "Any endpoint that reads req.body, req.query, or params must validate shape and types. Use Zod (schema.parse()) or Yup (schema.validate()) and use the parsed result. Do not trust raw request data.",
      "ai_risk_explanation": "AI adds TypeScript types for request data but omits runtime validation, assuming types are enough to enforce safety.",
      "vulnerable_example": "const { userId } = req.body; await db.orders.findByUser(userId);",
      "multiline": false
    },
    {
      "id": "unsafe-env-variable-access",
      "name": "Unsafe Environment Variable Access",
      "description": "process.env.SECRET or similar used without validation or with fallback to an insecure default. Missing or wrong env can lead to weak keys or accidental exposure.",
      "severity": "high",
      "pattern": "process\\.env\\.(?:SECRET|API_KEY|PASSWORD|TOKEN|PRIVATE)\\w*\\s*\\|\\s*['\"]?['\"]|process\\.env\\.\\w+\\s*(?:\\|\\|)\\s*['\"][^'\"]+['\"]",
      "fix_template": "Validate required env at startup: if (!process.env.SECRET) throw new Error('SECRET is required'). Never fall back to a default for secrets. Use a typed env module (e.g. validated with Zod).",
      "languages": ["typescript"],
      "cwe": "CWE-798",
      "owasp_category": "A07:2021 - Identification and Authentication Failures",
      "category": "configuration",
      "message": "Secrets are read from process.env without ensuring they are set or strong. Empty or default values can cause weak authentication or accidental exposure.",
      "technical_detail": "process.env.SECRET may be undefined or empty. Using it without check, or defaulting to a placeholder, can result in hardcoded fallbacks in logs or weak crypto. Validate and fail fast if required env is missing.",
      "ai_risk_explanation": "AI adds fallbacks like process.env.SECRET || 'dev-secret' to avoid runtime errors during local development, introducing insecure defaults.",
      "vulnerable_example": "const secret = process.env.SECRET || 'default-secret';",
      "multiline": false
    },
    {
      "id": "react-hook-xss-useeffect-innerhtml",
      "name": "React Hook Security Issues",
      "description": "useEffect or other hooks that set innerHTML, dangerouslySetInnerHTML, or document.write with user input. Enables XSS when user-controlled data is rendered as HTML.",
      "severity": "critical",
      "pattern": "useEffect\\s*\\([^)]*\\)\\s*[^{]*\\{[^}]*(?:innerHTML|dangerouslySetInnerHTML|document\\.write)\\s*[=.]",
      "fix_template": "Do not assign user input to innerHTML or dangerouslySetInnerHTML. Use text content (e.g. textContent, or React children). If HTML is required, sanitize with DOMPurify first.",
      "languages": ["typescript"],
      "cwe": "CWE-79",
      "owasp_category": "A03:2021 - Injection",
      "category": "xss",
      "message": "User input is written into the DOM as HTML inside a hook. Attackers can inject scripts and execute code in the user's browser.",
      "technical_detail": "Setting element.innerHTML or dangerouslySetInnerHTML with user input allows script injection. In useEffect this can run after render and still execute. Use safe APIs (textContent, React children) or sanitize with a library like DOMPurify.",
      "ai_risk_explanation": "AI uses useEffect to 'update the DOM' with user data and picks innerHTML or dangerouslySetInnerHTML for convenience, without considering XSS.",
      "vulnerable_example": "useEffect(() => { ref.current.innerHTML = userInput; }, [userInput]);",
      "multiline": false
    },
    {
      "id": "server-component-data-leakage",
      "name": "Server Component Data Leakage",
      "description": "Server components that fetch or receive sensitive data (user, password, token) and pass it to client components or serialize it without filtering. Sensitive fields can leak to the client bundle or props.",
      "severity": "high",
      "pattern": "(?:async\\s+)?function\\s+[A-Z]\\w+\\s*(?:Page|Component)?\\s*\\([^)]*\\)\\s*[^{]*\\{[^}]*(?:user\\.password|user\\.token|secret|credentials)[^}]*(?:return|children)",
      "fix_template": "Filter sensitive fields before passing to client components. Return only { id, name, ... } and never password, token, or internal IDs. Use server-only imports for secrets.",
      "languages": ["typescript"],
      "cwe": "CWE-200",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authentication",
      "message": "Sensitive data is included in server component output or props. It can be serialized to the client and exposed in the page or network.",
      "technical_detail": "React Server Components send serialized props to the client. Any sensitive field (password, token, internal IDs) in the returned object can end up in the client. Strip or omit these fields before returning from server components.",
      "ai_risk_explanation": "AI returns full user or entity objects from server components for convenience, without removing sensitive fields.",
      "vulnerable_example": "export default async function Profile() { const user = await getUser(); return <ClientProfile user={user} />; }",
      "multiline": true
    },
    {
      "id": "type-stripping-security-bypass",
      "name": "Type Stripping Security Bypass",
      "description": "Security or authorization checks exist only in TypeScript types (e.g. branded types or type guards) with no runtime enforcement. Types are erased; attackers can send unvalidated data.",
      "severity": "high",
      "pattern": "(?:isAdmin|isAuthenticated|hasRole)\\s*:\\s*boolean|(?:Brand|Opaque)\\s*<[^>]+>|type\\s+\\w+\\s*=\\s*\\w+\\s*&\\s*\\{.*(?:admin|auth|role)",
      "fix_template": "Enforce security at runtime: check session, validate JWT, or call auth middleware. Use the result of that check to branch (if (!ctx.user) throw ...). Do not rely on types or type guards alone for access control.",
      "languages": ["typescript"],
      "cwe": "CWE-863",
      "owasp_category": "A01:2021 - Broken Access Control",
      "category": "authorization",
      "message": "Access control or input safety is enforced only in the type system. At runtime there is no check, so unauthorized or invalid data can be accepted.",
      "technical_detail": "TypeScript types and type guards do not exist at runtime. Branded types (e.g. User & { __brand: 'Admin' }) or boolean flags in types do not prevent malicious requests. Implement real checks (session, JWT, middleware) and branch on their result.",
      "ai_risk_explanation": "AI adds type-level checks (narrowed types, branded types) to satisfy the compiler but does not add corresponding runtime enforcement.",
      "vulnerable_example": "if (user is AdminUser) { deleteAll(); } // no runtime check that user is actually admin",
      "multiline": false
    }
  ]
}
